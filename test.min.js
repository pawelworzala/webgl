function node(t,value){
    if(node[t]===undefined){
      node[t]=value
      return false
    }
    return node[t]
}

{

    const u=[]

    node(0,u)

}

{

    const u=node(0)

    function parse(v, w, x, y){
        //let z = [];
        //let match;
        let BB = x;
        const BC = new RegExp("{{([a-zA-Z0-9]+)}}","gm")
        return BB.replace(BC,match=>{
            const BD=match.substring(2,match["length"]-2)
            v.BD( BD, (BE,BF) => {
                y(BB.replace(new RegExp(match,"gm"),BF));
            });
            return v[BD]
        })
        /*while ((match = BC["exec"](BB)) !== null) {
            z["push"](match);
        }
        const replace = () => {
            let BG = BB;
            z.forEach((BH) => {
                const BI=BH.split('.')
                const BF=v[BH]//(BI.length?(v[BI[0]]?(v[BI[0]][BI[1]]):undefined):v[BH])
                if (BF !== undefined) {
                    BG = BG.replace("{{" + BH + "}}", BF ?? "");
                }
            });
            if (BG !== BB) {
                y(BG);
            }
        };
        z.forEach((BH) => {
            v.BD(BH, BF => {
                replace();
            });
        });
        replace();*/
    }
    
    node(1,parse)

    //const parse=node(1)
    
    function BJ(BK, v){
        const BL = (w) => {
            const BM = w.getAttributeNames ? w.getAttributeNames() : [];
            BM.forEach((BN) => {
                const BO = w.getAttribute(BN);
                if (BN.indexOf("red-") > -1) {
                    w.removeAttribute(BN);
                    w.BP = BO;
                    const BQ=u[BN["replace"]("red-", "")]
                    if(BQ){
                        BQ(w, v, BO);
                        //return false
                    }
                } else {
                    parse(v,w, BO, (BR) => {
                        w.setAttribute(BN, BR);
                    });
                    //return true
                }
            })
        };
        function BS(BK){
            const BT = BK
            const w = BK
            if(BT===undefined){
                return
            }
            /*if((!w)||(BU w==="string")){
                return
            }*/
            if (w.nodeName !== "#text") {
                BL(w)
                return
            }
            
            if (w.childNodes.length === 1) {
                parse(v,w, w.innerHTML, (BR) => {
                    w.innerHTML = BR;
                });
            }
            w.childNodes.forEach((node) => {
                BS(node);
            });
        };
        BS(BK);


        /*for(const BL of BV){
            const BW=BK.BX("[red-"+BL.BZ+"]")

            for(const BK of BW){

                const BN=BK.getAttribute("red-"+BL.BZ)

                BL.y(BK,v,BN)

            }
        */
        }


    
    
    node(2,BJ)
    //node(0,u)
    //node(1,parse)
    



}

{

    //function BD(){}
    
      /*  Object.prototype.BD = function (Ba, Bb) {
            const Bc = this
            !Bc.Bd ? Bc.Bd = [] : null;
            !Bc.Bd[Ba] ? Bc.Bd[Ba] = [] : null
            Bc.Bd[Ba]['push'](Bb)
            if (Bc.function hasOwnProperty() { [native code] }(Ba) && !Bc.function hasOwnProperty() { [native code] }('_' + Ba)) {
                Bc['_' + Ba] = Bc[Ba]
                try{
                //delete(Bc[Ba])
                }catch(e){}
            }
            if (!Bc.function hasOwnProperty() { [native code] }(Ba)) {
                Object.Bf(Bc, Ba, {
                    ["get"]: () => Bc['_' + Ba],
                    ["set"]: (value) => {
                        const Bg=Bc['_' + Ba]
                        Bc.Bd[Ba].forEach(Bb => {
                            Bb(Bg,value)
                        })
                        Bc['_' + Ba] = value
                    },
                })
            }
        }*/
    
    
        ///////////////////////////////////////////
    
    
      
    
            Object.prototype.BD = function (Ba, Bb) {
    
                let Bh = this.Bh
                if(Bh===undefined){
                    Bh={}
                    this.Bh = Bh
                }
                if(Bh[Ba]===undefined){
                    Bh[Ba]= {
                        Bi:[],
                        Bj:this[Ba],
                    }
                }
    
                Bh[Ba].Bi.push(Bb)
    
            if (!this["hasOwnProperty"](Ba)) {

                Object["defineProperty"](this, Ba, {
    
                    ["get"]: () => Bh[Ba].Bj,
                    ["set"]: (BF) => {
                            
                            for(const Bb of Bh[Ba].Bi){
                                Bb(Bh[Ba].Bj,BF)
                            }
                            Bh[Ba].Bj = BF
                        },
    
                })
            }
          
            }
    
    
    //}

}



{

    const u=node(0)
    
    function Bk(BK, v, BN){
        BK.addEventListener("click",(Bl) => {
            return (function (Bm) {
                return eval(Bm)
            }.bind(v))(BN)
        });
    }
    
    u["click"]=Bk
    

}



{

    
    /*Bn*/
    
    /*Bo*/
    node(3,function(Bp,Bq){
      return Object.assign(Bp,Bq)
    })
    
    node(4,async function Br(Bs,Bt){
        const Bu=await fetch(Bs)
        const BB=await Bu[Bt??"text"]()
        return BB
    })

    node(5,function(Bv){
      return new Uint8Array(Bv)
    })
    
    node(6,function(Bv){
      return new Float32Array(Bv)
    })
    
    node(7,function(Bv){
      return new Uint16Array(Bv)
    })
    

}



{

    

    node(8,function(Bw){

      const Bx=node(9)
    const By=node(10)

    const Bz=Bw.canvas.width / Bw.canvas.height;

        const J={
            CB: 5*9,
            Bz,
            CC: 1/1000,
            CD: 100,

            I(){
              return Bx.CE([], this.CB, this.Bz, this.CC, this.CD)
            }
          }
        

        node(11)(J)

        return J


    })


}

{

    node(12,function(Bw){

        Bw.enable(Bw.DEPTH_TEST);
        Bw.depthFunc(Bw.LEQUAL);
        Bw.clearColor(0.0, 0.0, 0.0, 0.0);
        Bw.clearDepth(10.0);

    })

    node(13,function(Bw,CF){

        const CG=CF ? CF.CH:null;
        Bw.bindFramebuffer(Bw.FRAMEBUFFER, CG);

        const clearColor=(CF && CF.clearColor) ? CF.clearColor:[0.0, 0.0, 0.0, 0.0];
        Bw.clearColor(...clearColor);

        if(CF){
            Bw.viewport(0.0, 0.0, CF.width, CF.height);
        }else{
            Bw.viewport(0.0, 0.0, Bw.canvas.width, Bw.canvas.height);
        }
        Bw.clear(Bw.COLOR_BUFFER_BIT | Bw.DEPTH_BUFFER_BIT);


    })


    node(11,function(Bp){

        const Bx=node(9)
        const By=node(10)

        return Object.assign(Bp,{

            x: Bp.x??node(14)(),
            CI(){
                const CI=Bx.CJ()
                Bx.CK(CI, CI, this.x.CL);
                Bx.CM(CI, CI, this.x.CN[2], [0,0,1]);
                Bx.CM(CI, CI, this.x.CN[1], [0,1,0]);
                Bx.CM(CI, CI, this.x.CN[0], [1,0,0]);
                Bx.CO(CI, CI, this.x.CO);
                return CI
            }

        })


    })


    node(15,function(Bp){

        node(3)(Bp,{

            CP:[],

            CQ(...CR){

                if(this.CP){
                    for(const CS of this.CP){
                        CS.CQ(...CR)
                    }
                }

                if(this.CT){
                    this.CT(...CR)
                }

            },

            CU(CV=Bx.CJ()) {
              
                this.CW=this.CI();
          
                Bx.CX(this.CW, CV, this.CW);
          
                for (const CS of this.CP) {
                    CS.CU(this.CW);
                }
            },

        })

    })


    node(14,function( CL =[0,0,0], CN=[0,0,0], CO=[1,1,1]){
        return { CL , CN, CO}
    })


    node(16,function(x=node(14),CY='CZ CY'){
        const CZ={name,x,
            add(CZ){
                this.CP.push(CZ)
            }
        }
        node(11)(CZ)
        node(15)(CZ)
        return CZ
    })


}

node(17,function(Bw,width,height){

    const CF={
      width,
      height,
      //renderbuffer: Bw.createRenderbuffer(),
      CH: Bw.createFramebuffer(),
      L: node(18)(Bw,undefined,width,height,'L'),
      Q: node(18)(Bw,undefined,width,height,'Q'),
    }


    //gl.bindRenderbuffer(Bw.RENDERBUFFER, CF.Ca);
    //gl.renderbufferStorage(Bw.RENDERBUFFER, Bw.DEPTH_COMPONENT24, width,height);

    // CH
    Bw.bindFramebuffer(Bw.FRAMEBUFFER, CF.CH);
    CF.CH.width = width;
    CF.CH.height = height;

    // Cb
    //gl.bindTexture(Bw.TEXTURE_2D, CF.L);
    /*Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MAG_FILTER, Bw.LINEAR);
    Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MIN_FILTER, Bw.LINEAR);
    Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_S, Bw.CLAMP_TO_EDGE);
    Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_T, Bw.CLAMP_TO_EDGE);*/
    //gl.texImage2D(Bw.TEXTURE_2D, 0, Bw.RGBA, CF.CH.width, CF.CH.height, 0, Bw.RGBA, Bw.UNSIGNED_BYTE, null);

    // Cc
    //gl.bindTexture(Bw.TEXTURE_2D, CF.Q);
    /*Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MAG_FILTER, Bw.LINEAR);
    Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MIN_FILTER, Bw.LINEAR);
    Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_S, Bw.CLAMP_TO_EDGE);
    Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_T, Bw.CLAMP_TO_EDGE);*/
    //gl.texImage2D(Bw.TEXTURE_2D, 0, Bw.DEPTH_COMPONENT24, CF.CH.width, CF.CH.height, 0, Bw.DEPTH_COMPONENT, Bw.UNSIGNED_INT, null);

    // Cd Ce
    Bw.framebufferTexture2D(Bw.FRAMEBUFFER, Bw.COLOR_ATTACHMENT0, Bw.TEXTURE_2D, CF.L, 0);
    Bw.framebufferTexture2D(Bw.FRAMEBUFFER, Bw.DEPTH_ATTACHMENT, Bw.TEXTURE_2D, CF.Q, 0);

    //gl.framebufferRenderbuffer(Bw.FRAMEBUFFER, Bw.DEPTH_ATTACHMENT, Bw.RENDERBUFFER, CF.Ca);

    //this.Cf();

    Bw.bindTexture(Bw.TEXTURE_2D, null);
    Bw.bindRenderbuffer(Bw.RENDERBUFFER, null);
    Bw.bindFramebuffer(Bw.FRAMEBUFFER, null);

    return CF

})

{
  
    node(19,function(){
        const canvas=document.createElement('canvas')
        canvas.width=window.innerWidth
        canvas.height=window.innerHeight
        document.body.append(canvas)
        return canvas
    })

}

{




    node(20,async function(canvas=node(19)() ){

      

      //if(canvas===undefined){
        /*canvas=document.createElement('canvas')
        canvas.width=window.innerWidth
        canvas.height=window.innerHeight
        document.body.append(canvas)*/
        //canvas=node(19)()
      //}
      const Bw = canvas.getContext("webgl2")

      //var Cg = Bw.getExtension('Ch');

      const Ci={
        Bw,
        Cj:[],
        add(CZ){
            this.Cj.push(CZ)
        }
      }
      


  

    Ci.Ce=[]

    const Ck=node(17)(Bw,512,512)
    Ci.Ce.push(Ck)

    const Cl=node(17)(Bw,512,512)
    Cl.Cm=await node(21)(Bw,"depth")
    Cl.clearColor=[0,0,0,1]
    Ci.Ce.push(Cl)


    /*const Cn=node(22);

    var Co=0, width=25
    var x=-(((Co-100)/100)*2)-1, Cq=(width/100)*2
    const Cr = await Cn(Ci, 1,0.5, -x, -x+Cq)*/

    /*var Co=25, width=25
    var x=-(((Co-100)/100)*2)-1, Cq=(width/100)*2
    this.Cs = new Ct(this, 1,0.5, -x, -x+Cq)

    var Co=50, width=25
    var x=-(((Co-100)/100)*2)-1, Cq=(width/100)*2
    this.Cu = new Ct(this, 1,0.5, -x, -x+Cq)



    var Co=50, width=50
    var x=-(((Co-100)/100)*2)-1, Cq=(width/100)*2
    this.Cv = new Ct(this, 0.0,-1.0, -x, -x+Cq)*/


    const Cw=node(23)(Bw,"/images/box.webp")

    Ci.DB=[]

      const DC=await node(24)(Ci)
      DC.x.CO=By(1.0)//[0.5,0.5,0.5]
      //render2d.x.CL=[0.0,0.0,0]
      DC.DD.d=Ck.L
      DC.DD.e=Cl.L
      Ci.DB.push(DC)

      /*const DE=await node(24)(Ci)
      DE.x.CO=[0.5,0.5,0.5]
      DE.x.CL=[0,0.5,0]
      DE.DD.d=CF.Q
      Ci.DB.push(DE)*/

      ///render2d.DD.d=B
      //engine.Cj.push(DC)


    //const d=B//buffer.L




    //gl.enable(Bw.CULL_FACE);
    Bw.enable(Bw.DEPTH_TEST);
    Bw.depthFunc(Bw.LEQUAL);
    //gl.colorMask(true, true, true, false);//.DF() 
    //gl.depthFunc(Bw.LEQUAL);

    //gl.blendFunc(Bw.SRC_ALPHA, Bw.ONE_MINUS_SRC_ALPHA);
    //gl.enable(Bw.BLEND);








    const J=node(8)(Bw)
    J.x.CL[2] = -6

    Ci.J=J



      function CQ(Bw, DD, DG, Cm){

        for(const K of Ci.Cj){
  
          if(K.DH){
            K.DH(DG)
          }
  
          if(!K.CQ){
              console.log('K DI CQ()...', K)
          }
          K.CQ(Bw, DD, DG, Cm)
  
       }
  
      }

      console.log('Ci',Ci);

    node(12)(Bw)

    var DJ = 0;
    let DK=0;

    var DH = function(DL) {


       const DG = (DL-DJ)*0.001;
       DK++;



       DJ = DL;


        const DD={
            I: J.I(),
            J: J.CI(),
            R:J.x.CL,
            a:J.x.CL,
            V:[Bw.canvas.width,Bw.canvas.height],
            W:DL,
            X:DG,
            DK:DK,
            f:Cw,
        }


        for (const CZ of Ci.Cj) {
          CZ.CU();
          if(CZ.DN){
            CZ.DO(X);
          }
        }

      //for(const DP of this.DQ){
      //  DP.bind(this)(X)
      //}


        for(const CF of Ci.Ce){
            node(13)(Bw,CF)
            CQ(Bw, DD, DG, CF.Cm)
        }

        node(13)(Bw)
        CQ(Bw, DD, DG)//, Cl.Cm)
        

        //render2d.DD.d=CF.L//colorTexture
        //print.CQ(Bw,DD)
        for(const CQ of Ci.DB){
            CQ.CQ(Bw,DD)
        }




       requestAnimationFrame(DH);


    }
    DH(0);

    return Ci

    })



}


{


        node(25,function(DR){
            

            const DS={}

            const DT=["positions", "normals", "texcoords", "indices"]


            if(DR[DT[0]]){
                DS.F=DR[DT[0]]
            }
            if(DR[DT[1]]){
                DS.G=DR[DT[1]]
            }
            if(DR[DT[2]]){
                DS.H=DR[DT[2]]
            }
            if(DR[DT[3]]){
                DS.DU=DR[DT[3]]
            }



            for(const DV of Object.keys(DR)){
                if(! DT.includes(DV)){
                    DS[DV]=DR[DV]
                }
            }

            return DS


        })



}

{

  const DW = 0.000001;
  const DX =  1/ DW;

    function Bx(){
      return Bx.CJ()
    }



    node(3)(Bx,{

      CJ() {
        return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1]
      },
      
      DY(a) {
        let DZ = [];
        DZ[0] = a[0];
        DZ[1] = a[1];
        DZ[2] = a[2];
        DZ[3] = a[3];
        DZ[4] = a[4];
        DZ[5] = a[5];
        DZ[6] = a[6];
        DZ[7] = a[7];
        DZ[8] = a[8];
        DZ[9] = a[9];
        DZ[10] = a[10];
        DZ[11] = a[11];
        DZ[12] = a[12];
        DZ[13] = a[13];
        DZ[14] = a[14];
        DZ[15] = a[15];
        return DZ;
      },

      CK(DZ, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
        let Da, Db, Dc, Dd;
        let De, Df, Dg, Dh;
        let Di, Dj, Dk, Dl;
      
        if (a === DZ) {
          DZ[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          DZ[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          DZ[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          DZ[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          Da = a[0];
          Db = a[1];
          Dc = a[2];
          Dd = a[3];
          De = a[4];
          Df = a[5];
          Dg = a[6];
          Dh = a[7];
          Di = a[8];
          Dj = a[9];
          Dk = a[10];
          Dl = a[11];
      
          DZ[0] = Da;
          DZ[1] = Db;
          DZ[2] = Dc;
          DZ[3] = Dd;
          DZ[4] = De;
          DZ[5] = Df;
          DZ[6] = Dg;
          DZ[7] = Dh;
          DZ[8] = Di;
          DZ[9] = Dj;
          DZ[10] = Dk;
          DZ[11] = Dl;
      
          DZ[12] = Da * x + De * y + Di * z + a[12];
          DZ[13] = Db * x + Df * y + Dj * z + a[13];
          DZ[14] = Dc * x + Dg * y + Dk * z + a[14];
          DZ[15] = Dd * x + Dh * y + Dl * z + a[15];
        }
      
        return DZ;
      },

      CO(DZ, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
      
        DZ[0] = a[0] * x;
        DZ[1] = a[1] * x;
        DZ[2] = a[2] * x;
        DZ[3] = a[3] * x;
        DZ[4] = a[4] * y;
        DZ[5] = a[5] * y;
        DZ[6] = a[6] * y;
        DZ[7] = a[7] * y;
        DZ[8] = a[8] * z;
        DZ[9] = a[9] * z;
        DZ[10] = a[10] * z;
        DZ[11] = a[11] * z;
        DZ[12] = a[12];
        DZ[13] = a[13];
        DZ[14] = a[14];
        DZ[15] = a[15];
        return DZ;
      },

      CM(DZ, a, Dm, Dn) {
        let x = Dn[0],
          y = Dn[1],
          z = Dn[2];
        let Do = Math.hypot(x, y, z);
        let s, c, t;
        let Da, Db, Dc, Dd;
        let De, Df, Dg, Dh;
        let Di, Dj, Dk, Dl;
        let Dp, Dq, Dr;
        let Ds, Dt, Du;
        let Dv, Dw, Dx;
      
        if (Do < DW) {
          return null;
        }
      
        Do = 1 / Do;
        x *= Do;
        y *= Do;
        z *= Do;
      
        s = Math.sin(Dm);
        c = Math.cos(Dm);
        t = 1 - c;
      
        Da = a[0];
        Db = a[1];
        Dc = a[2];
        Dd = a[3];
        De = a[4];
        Df = a[5];
        Dg = a[6];
        Dh = a[7];
        Di = a[8];
        Dj = a[9];
        Dk = a[10];
        Dl = a[11];
      
        // Dy Dz BW of Dz CN CI
        Dp = x * x * t + c;
        Dq = y * x * t + z * s;
        Dr = z * x * t - y * s;
        Ds = x * y * t - z * s;
        Dt = y * y * t + c;
        Du = z * y * t + x * s;
        Dv = x * z * t + y * s;
        Dw = y * z * t - x * s;
        Dx = z * z * t + c;
      
        // EB CN-specific CI ED
        DZ[0] = Da * Dp + De * Dq + Di * Dr;
        DZ[1] = Db * Dp + Df * Dq + Dj * Dr;
        DZ[2] = Dc * Dp + Dg * Dq + Dk * Dr;
        DZ[3] = Dd * Dp + Dh * Dq + Dl * Dr;
        DZ[4] = Da * Ds + De * Dt + Di * Du;
        DZ[5] = Db * Ds + Df * Dt + Dj * Du;
        DZ[6] = Dc * Ds + Dg * Dt + Dk * Du;
        DZ[7] = Dd * Ds + Dh * Dt + Dl * Du;
        DZ[8] = Da * Dv + De * Dw + Di * Dx;
        DZ[9] = Db * Dv + Df * Dw + Dj * Dx;
        DZ[10] = Dc * Dv + Dg * Dw + Dk * Dx;
        DZ[11] = Dd * Dv + Dh * Dw + Dl * Dx;
      
        if (a !== DZ) {
          // EE Dz x EF EG EH, EI Dz EJ EK EL
          DZ[12] = a[12];
          DZ[13] = a[13];
          DZ[14] = a[14];
          DZ[15] = a[15];
        }
        return DZ;
      },

      CX(DZ, a, b) {
        let Da = a[0],
          Db = a[1],
          Dc = a[2],
          Dd = a[3];
        let De = a[4],
          Df = a[5],
          Dg = a[6],
          Dh = a[7];
        let Di = a[8],
          Dj = a[9],
          Dk = a[10],
          Dl = a[11];
        let EM = a[12],
          EN = a[13],
          EO = a[14],
          EP = a[15];
      
        // EQ ER Dz ES ET of Dz EU CI
        let EV = b[0],
          EW = b[1],
          EX = b[2],
          EY = b[3];
        DZ[0] = EV * Da + EW * De + EX * Di + EY * EM;
        DZ[1] = EV * Db + EW * Df + EX * Dj + EY * EN;
        DZ[2] = EV * Dc + EW * Dg + EX * Dk + EY * EO;
        DZ[3] = EV * Dd + EW * Dh + EX * Dl + EY * EP;
      
        EV = b[4];
        EW = b[5];
        EX = b[6];
        EY = b[7];
        DZ[4] = EV * Da + EW * De + EX * Di + EY * EM;
        DZ[5] = EV * Db + EW * Df + EX * Dj + EY * EN;
        DZ[6] = EV * Dc + EW * Dg + EX * Dk + EY * EO;
        DZ[7] = EV * Dd + EW * Dh + EX * Dl + EY * EP;
      
        EV = b[8];
        EW = b[9];
        EX = b[10];
        EY = b[11];
        DZ[8] = EV * Da + EW * De + EX * Di + EY * EM;
        DZ[9] = EV * Db + EW * Df + EX * Dj + EY * EN;
        DZ[10] = EV * Dc + EW * Dg + EX * Dk + EY * EO;
        DZ[11] = EV * Dd + EW * Dh + EX * Dl + EY * EP;
      
        EV = b[12];
        EW = b[13];
        EX = b[14];
        EY = b[15];
        DZ[12] = EV * Da + EW * De + EX * Di + EY * EM;
        DZ[13] = EV * Db + EW * Df + EX * Dj + EY * EN;
        DZ[14] = EV * Dc + EW * Dg + EX * Dk + EY * EO;
        DZ[15] = EV * Dd + EW * Dh + EX * Dl + EY * EP;
        return DZ;
      },


      EZ(DZ, a) {
        let Da = a[0],
          Db = a[1],
          Dc = a[2],
          Dd = a[3];
        let De = a[4],
          Df = a[5],
          Dg = a[6],
          Dh = a[7];
        let Di = a[8],
          Dj = a[9],
          Dk = a[10],
          Dl = a[11];
        let EM = a[12],
          EN = a[13],
          EO = a[14],
          EP = a[15];
      
        let Dp = Da * Df - Db * De;
        let Dq = Da * Dg - Dc * De;
        let Dr = Da * Dh - Dd * De;
        let Ea = Db * Dg - Dc * Df;
        let Eb = Db * Dh - Dd * Df;
        let Ec = Dc * Dh - Dd * Dg;
        let Ed = Di * EN - Dj * EM;
        let Ee = Di * EO - Dk * EM;
        let Ef = Di * EP - Dl * EM;
        let Eg = Dj * EO - Dk * EN;
        let Ds = Dj * EP - Dl * EN;
        let Dt = Dk * EP - Dl * EO;
      
        // Eh Dz Ei
        let Ej =
          Dp * Dt - Dq * Ds + Dr * Eg + Ea * Ef - Eb * Ee + Ec * Ed;
      
        if (!Ej) {
          return null;
        }
        Ej = 1.0 / Ej;
      
        DZ[0] = (Df * Dt - Dg * Ds + Dh * Eg) * Ej;
        DZ[1] = (Dc * Ds - Db * Dt - Dd * Eg) * Ej;
        DZ[2] = (EN * Ec - EO * Eb + EP * Ea) * Ej;
        DZ[3] = (Dk * Eb - Dj * Ec - Dl * Ea) * Ej;
        DZ[4] = (Dg * Ef - De * Dt - Dh * Ee) * Ej;
        DZ[5] = (Da * Dt - Dc * Ef + Dd * Ee) * Ej;
        DZ[6] = (EO * Dr - EM * Ec - EP * Dq) * Ej;
        DZ[7] = (Di * Ec - Dk * Dr + Dl * Dq) * Ej;
        DZ[8] = (De * Ds - Df * Ef + Dh * Ed) * Ej;
        DZ[9] = (Db * Ef - Da * Ds - Dd * Ed) * Ej;
        DZ[10] = (EM * Eb - EN * Dr + EP * Dp) * Ej;
        DZ[11] = (Dj * Dr - Di * Eb - Dl * Dp) * Ej;
        DZ[12] = (Df * Ee - De * Eg - Dg * Ed) * Ej;
        DZ[13] = (Da * Eg - Db * Ee + Dc * Ed) * Ej;
        DZ[14] = (EN * Dq - EM * Ea - EO * Dp) * Ej;
        DZ[15] = (Di * Ea - Dj * Dq + Dk * Dp) * Ej;
      
        return DZ;
      },
      
      //perspectiveNO
      CE(DZ, El, Bz, CC, CD) {
        const Em = 1.0 / Math.tan(El / 2);
        DZ[0] = Em / Bz;
        DZ[1] = 0;
        DZ[2] = 0;
        DZ[3] = 0;
        DZ[4] = 0;
        DZ[5] = Em;
        DZ[6] = 0;
        DZ[7] = 0;
        DZ[8] = 0;
        DZ[9] = 0;
        DZ[11] = -1;
        DZ[12] = 0;
        DZ[13] = 0;
        DZ[15] = 0;
        if (CD != null && CD !== DX) {
          const En = 1 / (CC - CD);
          DZ[10] = (CD + CC) * En;
          DZ[14] = 2 * CD * CC * En;
        } else {
          DZ[10] = -1;
          DZ[14] = -2 * CC;
        }
        return DZ;
      }


    
    })
    
    node(9,Bx)
    

}



{

    node(26,function(Bw,Bv,Eo){

      if(Eo===undefined){
        Eo = Bw.ARRAY_BUFFER
      }
      const CF = Bw.createBuffer();
      Bw.bindBuffer(Eo, CF);
      Bw.bufferData(Eo, Bv, Bw.STATIC_DRAW);
      return CF;

    })
    


    node(27,function(Bw,Cm,CF,CY,Ep,Eo){
      
      if(Eo===undefined){
        Eo=Bw.ARRAY_BUFFER
      }

      Bw.bindBuffer(Eo, CF);

       const CG = Bw.getAttribLocation(Cm.Eq, CY);

       if(CG>-1){
         if(CY==='Er'){
          Bw.vertexAttribIPointer(CG, Ep, Bw.UNSIGNED_SHORT, false,0,0) ;
         }else{
          Bw.vertexAttribPointer(CG, Ep, Bw.FLOAT, false,0,0) ;
         }
        Bw.enableVertexAttribArray(CG);
       }

    })

    node(28,function(Bw,DR){

      const Es=node(6)
      const Et=node(7)

      const Ce={}

      for(const DV of Object.keys(DR)){

        if(DV==='DU'){

          Ce[DV] = node(26)(Bw, Et(DR[DV]), Bw.ELEMENT_ARRAY_BUFFER)

        }else{
          Ce[DV] = node(26)(Bw, Es(DR[DV]))
        }

      }
      
      return Ce

    })


    node(29,function(Bw,Cm,Ce){

      const Eu = Bw.createVertexArray();
      Bw.bindVertexArray(Eu);

      for(const DV of Object.keys(Ce)){

        let Ev= (DV==='DU')?1:3
        if(DV==='H'){
          Ev=2
        }
        let Eo= (DV==='DU')? Bw.ELEMENT_ARRAY_BUFFER: Bw.ARRAY_BUFFER

          node(27)(Bw,Cm, Ce[DV], DV,Ev,Eo)
            
      }

      Bw.bindVertexArray(null);

      return Eu

    })

    node(30,function(...CR){
      return node(31)(...CR)
    })

    node(31,function(Ci,DR,Cm,Ew=true){

      const Bw=Ci.Bw


      let Ce
      const Ex={
        DR,
        Ce: Ce=node(28)(Bw, DR),
        Cm,
        Eu: node(29)(Bw,Cm,Ce),
        Ey:Bw.TRIANGLES,
        DD:{},

        CT(Bw,DD,DG,Cm){

            Cm=Cm ?? this.Cm

            Bw.useProgram(Cm.Eq);


           
            Bw.bindVertexArray(this.Eu);

            
            const Ez=node(32)(Bw,Cm)

            Ez.set(DD)
            Ez.set(this.DD??{})
            Ez.set({
              K:this.CW??this.CI(),
            })
          
          if(this.DR.DU){
            Bw.bindBuffer(Bw.ELEMENT_ARRAY_BUFFER, this.Ce.DU);

            Bw.drawElements(this.Ey, this.DR.DU.length, Bw.UNSIGNED_SHORT, 0);
          }else{
            let k=this.DR.F.length/3
            //if(this.Ey===Bw.POINTS){
            //  k=this.DR.F.length/3
            //}
            Bw.drawArrays(this.Ey, 0, k);
          }
        }
      }

      node(11)(Ex)
      node(15)(Ex)

      if(Ew){
          Ci.add(Ex)
      }

      return Ex


    })


}



{

    node(21,async function(Bw,CY){

      const Cm={
        CY,
      }

      const Br=node(4)

      let FB="/shaders.min"//-min"
      //try{
      //  if(FE!==undefined){
      //    FB="/shaders"
      //  }
      //}catch(e){}

      const FF = await Br(FB+"/"+CY+".vert")
      const FH = await Br(FB+"/"+CY+".frag")

      Cm.Eq = await node(33)(Bw,FF,FH)

      return Cm

    })

    node(34,function(Bw,FJ,FK){

      const Cm=Bw.createShader(FK);
      Bw.shaderSource(Cm, FJ);
      Bw.compileShader(Cm);

      if (! Bw.getShaderParameter(Cm, Bw.COMPILE_STATUS)) {
        console.log('FJ',FJ)
        console.log(Bw.getShaderInfoLog(Cm));
      }

      return Cm

    })


    node(33,async function(Bw,FF,FH){

      const FL = await node(34)(Bw,FF,Bw.VERTEX_SHADER)
      const FM = await node(34)(Bw,FH,Bw.FRAGMENT_SHADER)

      const FN = Bw.createProgram();
      Bw.attachShader(FN, FL);
      Bw.attachShader(FN, FM);
      Bw.linkProgram(FN);

      if (! Bw.getProgramParameter(FN, Bw.LINK_STATUS)) {
        console.log(Bw.getProgramInfoLog(FN));
      }

      return FN

    })

}


{

   function FO(value) {
      return (value & (value - 1)) == 0;
   }

   node(35,function(Bw,FP,width=1,height=1,FQ='FR'){
        Bw.bindTexture(Bw.TEXTURE_2D, FP);

        if(FO(width) && FO(height) && (FQ!=='Q') ) {
            Bw.generateMipmap(Bw.TEXTURE_2D);
        } else {
            const FS=(FQ==='Q') ? Bw.NEAREST:Bw.LINEAR;
            Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MAG_FILTER, FS);
            Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MIN_FILTER, FS);
            if(FQ!=='Q'){
                Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_S, Bw.CLAMP_TO_EDGE);
                Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_T, Bw.CLAMP_TO_EDGE);
            }
        }
   })

   node(18,function(Bw,L=[0, 0, 255, 255],width=1,height=1,FQ='FR'){
      const FP = Bw.createTexture();
      Bw.bindTexture(Bw.TEXTURE_2D, FP);

      if(FQ==='FR'){
        const h = node(5)(L)
        Bw.texImage2D(Bw.TEXTURE_2D, 0, Bw.RGBA, width, height, 0, Bw.RGBA, Bw.UNSIGNED_BYTE, h);
      }else if(FQ==='L'){
        Bw.texImage2D(Bw.TEXTURE_2D, 0, Bw.RGBA, width, height, 0, Bw.RGBA, Bw.UNSIGNED_BYTE, null);
      }else if(FQ==='Q'){
        Bw.texImage2D(Bw.TEXTURE_2D, 0, Bw.DEPTH_COMPONENT24, width, height, 0, Bw.DEPTH_COMPONENT, Bw.UNSIGNED_INT, null);
      }

      node(35)(Bw,FP,width,height,FQ)

      return FP;
   })


    node(23,function FT(Bw, FU) {
        const FP=node(18)(Bw)
 
        const FV = new Image();
        FV.onload = function() {
            Bw.bindTexture(Bw.TEXTURE_2D, FP);
            Bw.texImage2D(Bw.TEXTURE_2D, 0, Bw.RGBA, Bw.RGBA, Bw.UNSIGNED_BYTE, FV);
         
            node(35)(Bw,FP,FV.width,FV.height)
        };
        FV.src = FU;
     
        return FP;
     })



}

{


    node(32,function FW(Bw,Cm){
       
        let FX=0
        Bw.activeTexture(Bw.TEXTURE0)
        Bw.bindTexture(Bw.TEXTURE_2D,null)
      
        return {
            set(DD){
                
                for(const DV of Object.keys(DD)){

                    const CG = Bw.getUniformLocation(Cm.Eq,DV)
                    const Bj=DD[DV]
                
                    if((! CG)||(Bj===undefined)){
                        return
                    }
                    
                    
                    
                    if((Bj!==undefined)&&(Bj["constructor"]["name"]==="WebGLTexture")){
                        Bw.uniform1i(CG,FX)
                        Bw.activeTexture(Bw.TEXTURE0+FX)
                        Bw.bindTexture(Bw.TEXTURE_2D,Bj)
                        FX++
                    }else{
                        
                        switch(Bj.length) {
                            case 16:
                                Bw.uniformMatrix4fv(CG,null,Bj)
                                break;
                            case 4:
                                Bw.uniform4fv(CG,Bj)
                                break;
                            case 3:
                                Bw.uniform3fv(CG,Bj)
                                break;
                            case 2:
                                Bw.uniform2fv(CG,Bj)
                                break;
                            FR:
                                Bw.uniform1f(CG,Bj)
                          }
                        

                    }
            
                }
                
            }
        }
    })


}

{


    function By(FY){
        return By.CJ(FY)
      }

    node(3)(By,{

        CJ(x,y,z) {
          if(x===undefined){
            x=0.0
          }
          if(y===undefined){
            y=x
          }
          if(z===undefined){
            z=y
          }
          return [x,y,z]
        },

        FZ(a){
          let x = a[0];
          let y = a[1];
          let z = a[2];
          return Math.hypot(x, y, z);
        },

        add(DZ, a, b) {
          DZ[0] = a[0] + b[0];
          DZ[1] = a[1] + b[1];
          DZ[2] = a[2] + b[2];
          return DZ;
        },
        
        Fa(DZ, a, b) {
          DZ[0] = a[0] - b[0];
          DZ[1] = a[1] - b[1];
          DZ[2] = a[2] - b[2];
          return DZ;
        }

    })


    node(10,By)


}

{



    node(24,async function(Ci){



        //const Ci=await node(20)()
        const Bw=Ci.Bw



        
        //engine.J.x.CL = By.CJ()


        const FN=await node(21)(Bw,"render2d")

        let DR=await node(4)("/models/quad.json","json")
        
        DR=node(25)(DR)

        //const B=node(23)(Bw,"/wp-includes/images/box.webp")
        //const B=node(23)(Bw,"/images/box.webp")
        

        const Ex=node(30)(Ci, DR, FN, false)

        

        /*const DD={
            //colorTexture:B,
        }


        const CQ={
            DD,
            CQ(Bw,DD){
                node(3)(Ex.DD,this.DD)
                //mesh.DD=this.DD;
                Ex.CQ(Bw,DD)
            }
        }*/

        //mesh.DD.d=d


        //engine.Cj.push(CQ)



        return Ex












        //node(36)('./models/stickman/scene.Ff')





    })



}


    {
        
        function Fg(BF){
            return {
                '5120': Fh,
                '5121': Uint8Array,
                '5122': Fi,
                '5123': Uint16Array,
                '5124': Fj,
                '5125': Fk,
                '5126': Float32Array
            }[BF]
        }
        
        function Fl(BF){
            return {
                'Fm': 1,
                'Fn': 2,
                'Fo': 3,
                'Fp': 4,
                'Fq': 4,
                'Fr': 9,
                'Fs': 16
            }[BF]
        }
        
        function Ft(Ff, Fu) {
            const Fv = Ff.Fw[Fu];
            const Fx = Ff.Fy[Fv.Fx];
            const Fz = Fg(Fv.GB);
            const CF = Ff.Ce[Fx.CF];
            Fv.Ep=Fl(Fv.Bt)
            const Bv=new Fz(
              CF,
              Fx.GC + (Fv.GC || 0),
              Fv.k * Fv.Ep)
            return Bv/*{
              Fv,
              Bv,
          }*/
        }
        
        
        
        node(36,async function(Ci,Bs){
        
            const Bw=Ci.Bw
        
            //const Cm=await node(34)('GD.FG','GD.FI')
            //const GE=await node(34)('GD')
            const Cm=await node(21)(Bw,"skin")
        
            
            let FB=Bs.replace(Bs.split('/').pop(),'')
        
            const Ff=await node(4)(Bs,"json")
        
            //console.log(Ff)
        
            for(const DV of Object.keys(Ff.Ce)){
                const FU=FB+'/'+Ff.Ce[DV].Bs
                Ff.Ce[DV]=await node(4)(FU,'GF')
            }
        
            
        
            Ff.Fw=Ff.Fw.map((Fv,GG)=>{
                return Ft(Ff,GG)
            })
        
            Ff.Cx=(Ff.Cx??[]).map(FV=>{
                return node(23)(Bw, FB+'/'+FV.Bs)
            })
        
            Ff.GH=(Ff.GH??[]).map(FP=>{
                return Ff.Cx[FP.x]
            })
        
            Ff.GI=(Ff.GI??[]).map(GJ=>{
                const GK={}
                if(GJ.GL){
                    const GM=GJ.GL
                    GK.GN= GM.GO??[1,1,1,1]
                    GK.B=GM.GP?gltf.GH[GM.GP.GG]:null//createTexture(Bw,[128,128,128,255])
                }
                GK.Y=GJ.Y?(Ff.GH[GJ.Y.GG]):null//createTexture(Bw,[0,0,255,255])
                GK.Z=GJ.Z?(Ff.GH[GJ.Z.GG]):null//createTexture(Bw,[128,128,128,255])
                return GK
            })
        
            Ff.GQ=Ff.GQ.map(Ex=>{
                let GR={geometry:{}}
                for(const DV of Object.keys(Ex.GS[0].BM)){
                    GR.DR[(DV.replace('GT','').GU()+'s').replace('GV','s')]=Ff.Fw[Ex.GS[0].BM[DV]]
                }
          
                GR.DR.DU=Ff.Fw[Ex.GS[0].DU]
                GR.GJ=Ff.GI ? Ff.GI[Ex.GS[0].GJ]:{}
          
                return GR
            })
        
            const GW = [];
            const GX = Ff.GY;
            Ff.GY = Ff.GY.map((n) => {
              const {name, GD, Ex, CL, CN, CO} = n;
        
              const GZ = node(14)(CL, CN, CO);
              const Ga = node(16)(GZ, CY);
              const Gb = Ff.GQ[Ex];
              if (GD !== undefined) {
                GW.push({node: Ga, Ex: Gb, Gc: GD});
              } else if (Gb) {
                const Ex=node(30)(Ci,Gb.DR,Cm,node)
                Ex.DD=Gb.GJ
                //node.add(Ex)
                //node.Gd.push(Ex);
                //engine.GQ.push(Ex)
              }
              return Ga;
            });
        
            Ff.DN = (Ff.DN??[]).map((GD) => {
              const Er = GD.Er.map(Ge => Ff.GY[Ge]);
              const Bv = Ff.Fw[GD.Gf]
              return node(37)(Bw,Er, Bv);
            });
        
            for (const {node:Ga, Ex, Gc} of GW) {
              //console.log('Br K Ex: ',Ex)
              const Gg=node(30)(Ci,Ex.DR,Cm,Ga)
              Gg.DD=Ex.GJ
              const GD=Ff.DN[Gc]
              Gg.GD=GD
              //node.add(Gg)
              //node.Gd.push(Gg);
              //engine.GQ.push(Gg)
            }
        
            Ff.GY.forEach((Ga, Ge) => {
              const CP = GX[Ge].CP;
              if (CP) {
                Gh(Ff.GY, Ga, CP);
              }
            });
        
            for (const CZ of Ff.Gi) {
              CZ.Gj = node(16)(node(14)(), CZ.CY);
              Gh(Ff.GY, CZ.Gj, CZ.GY);
            }
        
            Ci.add(Ff.Gi[0].Gj)
        
            console.log(Ff)

            //for(const Ex of Ff.GQ){
            //    Ci.add(Ex)
            //}
        
            //node(3)(this,Ff)
        
            //gltf.Gi[0].Gj.CU()

            const K=node(16)()
            node(3)(K,Ff)


            return K

            
        })


        
        
        function Gh(GY, Ga, Gk) {
            Gk.forEach((Gl) => {
                const CS = GY[Gl];
                //child.Gm(node);
                Ga.add(CS)
            });
        }
        
        
        
        
    
    }
    
    

    {
    
        function Gn(Go, Bp, Gp) {
            Go += (Bp - Go)*Gp;
            return Go
        }
        function Gq(Go, Bp, Gp) {
            return Go.map((p,i)=>lerp(Go[i], Bp[i], Gp))
        }
        
       
        
        
        node(38,function(X){

            return
        
        
                if(!this.Gr){
                    this.Gr = {}
                }
        
        
                if(!this['Gs']||!this.Gs.length){
                    return
                }
        
                const GD=this['DN'][0]
        
                    const Gt=this.Gs[0]
        
        
        
                    this.Gr.DK = this.Gr.DK??0
                    this.Gr.Gp=this.Gr.Gp??0.0;
                    this.Gr.Gu=this.Gr.Gu??0
                    this.Gr.DL=this.Gr.DL??0
        
                
                    const Gv=0.035
        
                    this.Gr.Gp=this.Gr.DL/frametime
                    this.Gr.DL+=X
        
                    const Gw=()=>{
                    while(this.Gr.Gp>frametime){
                        this.Gr.DK++
                        this.Gr.DL=0
                        this.Gr.Gp=0
                    }
                    }
                    if(this.Gr.DK>this.Gr.Gu){
                    this.Gr.DK=0
                    Gw()
                    }
                    if(this.Gr.DL>frametime){
                    Gw()
                    }
                    
        
            for(const Gx of Gt['Gy']){
                    const Bp=Gx['Bp']
                    const Gz=this.GY[Bp['node']]
                    const FX=Gt['HB'][Gx['FX']]
                    
                    const HC={'CL':'HD','CN':'CN','CO':'CO',}[Gx.Bp['FB']]
                    const Do=(HC==='CN')?4:3
        
        
                    const Fv=this.Fw[FX['HE']].Bv
                    
                    if(!this.Gr.Gu){
                        this.Gr.Gu=Fv.length/len
                    }
                
                    if(HC==='CN'){
                        var value=[Fv[(this.Gr.DK*Do)+0],Fv[(this.Gr.DK*Do)+1],Fv[(this.Gr.DK*Do)+2],Fv[(this.Gr.DK*Do)+3]]
                    }else{
                        var value=[Fv[(this.Gr.DK*Do)+0],Fv[(this.Gr.DK*Do)+1],Fv[(this.Gr.DK*Do)+2]]
                    }
        
                    let HF=[value[0],value[1],value[2],value[3],]
                
                    const BG=Gq(HF, value, this.Gr.Gp)
        
                    Gz.x[HC]=BG
                    }
        
        
        })
    
    }
    
    

    {
    
      
        
        node(37,function(Bw, Er, HG){
              this.Er = Er;
              this.Gf = [];
              this.HH = [];
            
              this.HI = new Float32Array(Er.length * 16);
        
              for (let i = 0; i < Er.length; ++i) {
                this.Gf.push(new Float32Array(
                    HG.CF,
                    HG.GC + Float32Array.HJ * 16 * i,
                    16));
                this.HH.push(new Float32Array(
                    this.HI.CF,
                    Float32Array.HJ * 16 * i,
                    16));
              }
        
              this.HK = Bw.createTexture();
              Bw.bindTexture(Bw.TEXTURE_2D, this.HK);
              Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MIN_FILTER, Bw.NEAREST);
              Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_MAG_FILTER, Bw.NEAREST);
              Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_S, Bw.CLAMP_TO_EDGE);
              Bw.texParameteri(Bw.TEXTURE_2D, Bw.TEXTURE_WRAP_T, Bw.CLAMP_TO_EDGE);
            
            
            return {
                HL(node) {
                const HM = Bx.CJ()
                Bx.EZ(HM,node.CW);
            
                for (let j = 0; j < this.Er.length; ++j) {
                    const Gz = this.Er[j];
                    const HN = this.HH[j];
                    Bx.CX(HN, HM, Gz.CW);
                    Bx.CX(HN, HN, this.Gf[j]);
                }
                Bw.bindTexture(Bw.TEXTURE_2D, this.HK);
                Bw.texImage2D(Bw.TEXTURE_2D, 0, Bw.RGBA32F, 4, this.Er.length, 0,
                                Bw.RGBA, Bw.FLOAT, this.HI);
                }
            }
        })


    
    }
    
    

{



    node(39,async function(Ci){



        //const Ci=await node(20)()
        const Bw=Ci.Bw



        const HO=5
        function HP(){
            return (HO / 2)-Math.random()*HO
        }

        const HQ=0.06812
        function CO(){
            return (HQ / 3)+Math.random()*HQ
        }

        const HR=0.072
        function HS(){
            return (HR / 10)+Math.random()*HR*0.13
        }




        const FN=await node(21)(Bw,"default")

        let DR=await node(4)("/models/box.json","json")
        DR=node(25)(DR)

        const B=node(23)(Bw,"/images/box.webp")

        const GQ=[]

        const k=100.0;

        for(let x=0; x< k / 3.5 ;x++){
            for(let y=0;y< k / 28.0 ;y++){
                const Ex=node(31)(Ci, DR, FN)
                Ex.x.CL=[HP(), HP(), HP()]
                const HQ=CO()
                Ex.x.CO=[HQ,HQ,HQ]
                Ex.x.HS=[HS(),HS(),HS()]

                Ex.DD={
                    B,
                }

                //mesh.Ey=Bw.LINE_STRIP;

                GQ.push(Ex)
            }
        }



            for(const Ex of GQ){

                Ex.DH=function(DG){

                    Ex.x.CN=Ex.x.CN.map((n,i)=>n+Ex.x.HS[i])

                }
            }
            //const CN=[DG*0.3, DG*0.12, DG*0.45]
            //this.x.CN=this.x.CN.map((n,i)=>n+CN[i])



        //engine.Cj.push(...GQ)
















        //node(36)('./models/stickman/scene.Ff')





    })



}


{



    node(40,async function(Ci){



        //const Ci=await node(20)()
        const Bw=Ci.Bw



        

        const HT=[]
        for(let i=0;i<20;i++){
            HT.push({point:[Math.random(),Math.random(),0]})
        }


        //const HU=(HT.length/3)-2

        console.log('HT',HT)

        /*let Do=1000000;
        let HV
        for(const HW of HT){
            const HX=By.FZ(HW.HW);
            HW.length=HX;
            if(HX<len){
                Do=HX;
                HV=HW
            }
        }*/
        const HY=[];

        function HZ(Ha){
            let Hb=[];

            for(const HW of HT){
                const Hc=By.Fa([],HW.HW,Ha.HW);
                HW.Do=By.FZ(Hc);
            }
            let Do=100000
            let Hd
            let He
            let Hf
            for(const HW of HT){
                if(HW!==Ha){
                    if(Do>point.Do){
                        Do=HW.Do;
                        Hf=He;
                        He=Hd;
                        Hd=HW;
                    }
                }
            }

            if(Ha&&point2&&point3){
                Hb.push([Ha,Hd,He])
            }
            if(Hd&&point4&&point3){
                Hb.push([Hd,Hf,He])
            }


            return Hb;
        }
        
        for(const HW of HT){
            const Hg=HZ(HW)
            if(Hg.length){
                HY.push(...Hg);
            }
        }
        //var Hh = Hi.Hj(F);
        //var DS = Hi(Hh.Hk, Hh.Hl, Hh.Hm);
        const F=[]
        for(const Hn of HY){
            F.push(...Hn)
        }
        //const DU = Hi(F,null,2);//earcut(F,[4]);
        //console.log('DU',DU)
        //const F=[]
        //for(const p of Ho){
        //    F.push(...HY[p])
        //}
        //const DU=Ho

        const FN=await node(21)(Bw,"default")
    
        {

            //const F=[]
            //points.map(HP=>positions.push(...HP.HW))

            let DR={positions}
            
            DR=node(25)(DR)

            //const B=node(23)(Bw,"/wp-includes/images/box.webp")

            

            const Ex=node(31)(Ci, DR, FN)

            Ex.Ey=Bw.POINTS;

            //engine.Cj.push(Ex)
        }



        {
            const Hp=[]
            HY.map(Hq=>triangle.map(HP=>tpositions.push(...HP.HW)))

            let Hr={positions:Hp}
            
            Hr=node(25)(Hr)

            //const B=node(23)(Bw,"/wp-includes/images/box.webp")

            

            const Hs=node(31)(Bw, Hr, FN)

            //tmesh.Ey=Bw.LINES;

            Ci.Cj.push(Hs)
        }
















        //node(36)('./models/stickman/scene.Ff')





    })



}


{



    node(41,async function(Ci){



        //const Ci=await node(20)()
        const Bw=Ci.Bw



        
        //engine.J.x.CL = By.CJ()


        const FN=await node(21)(Bw,"render2d")

        let DR=await node(4)("/models/quad.json","json")
        
        DR=node(25)(DR)

        //const B=node(23)(Bw,"/wp-includes/images/box.webp")
        const B=node(23)(Bw,"/images/box.webp")
        

        const Ex=node(31)(Ci, DR, FN)

        Ex.x.CO=[0.8,0.8,0.8]

        Ex.DD.d=B


        //engine.Cj.push(Ex)
















        //node(36)('./models/stickman/scene.Ff')





    })



}


{



    node(42,async function(Ci){



        //const Ci=await node(20)()
        //const Bw=Ci.Bw





        

        await node(36)(Ci,'/models/stickman/scene.Ff')





    })



}


{

    node(43,async function(){


        const Ci=await node(20)()


        //node(41)()

        //node(40)()

        node(39)(Ci)


        //node(42)(Ci)









        node(44)()




    })

    /*window.addEventListener('Ht', () => {
        node(43)()
    })*/

    node(43)()









    node(44,function(){


        const v={}

        v["loadScene"]=function(){
            console.log('CZ Br...')
        }

        node(2)(document.body, v)


    })




}

