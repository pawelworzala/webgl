function node(Q,value){
    if(node[Q]===undefined){
      node[Q]=value
      return false
    }
    return node[Q]
}{

    
    /*R*/
    
    /*S*/
    
    node(0,async function T(U,V){
        const W=await fetch(U)
        const X=await W[V??"text"]()
        return X
    })
    
    node(1,function(Y){
      return new Float32Array(Y)
    })
    
    node(2,function(Y){
      return new Uint16Array(Y)
    })
    
    node(3,function(Z,a){
      return Object.assign(Z,a)
    })
    

}

{

    

    node(4,function(b){

      const c=node(5)
    const d=node(6)

    const e=b.canvas.width / b.canvas.height;

        const J={
            f: 5*9,
            e,
            g: 1/1000,
            h: 1000,

            I(){
              return c.i([], this.f, this.e, this.g, this.h)
            }
          }
        

        node(7)(J)

        return J


    })


}{

    node(8,function(b){

        b.enable(b.DEPTH_TEST);
        b.depthFunc(b.LEQUAL);
        b.clearColor(0.0, 0.0, 0.0, 0.0);
        b.clearDepth(1.0);

    })

    node(9,function(b){

        b.viewport(0.0, 0.0, b.canvas.width, b.canvas.height);
        b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);

    })


    node(7,function(Z){

        const c=node(5)
        const d=node(6)

        return Object.assign(Z,{

            j:{
                k:d.l(),
                m:d.l(),
                n:d.l(1.0),
            },
            o(){
                const o=c.l()
                c.p(o, o, this.j.k);
                c.q(o, o, this.j.m[2], [0,0,1]);
                c.q(o, o, this.j.m[1], [0,1,0]);
                c.q(o, o, this.j.m[0], [1,0,0]);
                c.n(o, o, this.j.n);
                return o
            }

        })


    })


}
/*r*/

{

    node(10,async function(canvas){

      if(canvas===undefined){
        canvas=document.createElement('canvas')
        canvas.width=window.innerWidth
        canvas.height=window.innerHeight
        document.body.append(canvas)
      }
      const b = canvas.getContext("webgl2")
      




















      const s={
        b,
        t:[],
      }








    const J=node(4)(b)
    J.j.k[2] = -6

    s.J=J







    node(8)(b)

    var u = 0;

    var v = function(w) {


       const x = (w-u)*0.001;




       u = w;


        const z={
            I: J.I(),
            J: J.o(),
        }


       node(9)(b)


       for(const K of s.t){

          if(K.v){
            K.v(x)
          }

            K.BB(b, z)

       }



       requestAnimationFrame(v);


    }
    v(0);


    return s

    })



}
{


        node(11,function(BC){
            

            const BD={}

            const BE=["positions", "normals", "texcoords", "indices"]


            if(BC[BE[0]]){
                BD.F=BC[BE[0]]
            }
            if(BC[BE[1]]){
                BD.G=BC[BE[1]]
            }
            if(BC[BE[2]]){
                BD.H=BC[BE[2]]
            }
            if(BC[BE[3]]){
                BD.BF=BC[BE[3]]
            }



            for(const BG of Object.keys(BC)){
                if(! BE.includes(BG)){
                    BD[BG]=BC[BG]
                }
            }

            return BD


        })



}{

  const BH = 0.000001;
  const BI =  1/ BH;

    function c(){
      return c.l()
    }



    node(3)(c,{

      l() {
        return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1]
      },
      
      BJ(a) {
        let BK = [];
        BK[0] = a[0];
        BK[1] = a[1];
        BK[2] = a[2];
        BK[3] = a[3];
        BK[4] = a[4];
        BK[5] = a[5];
        BK[6] = a[6];
        BK[7] = a[7];
        BK[8] = a[8];
        BK[9] = a[9];
        BK[10] = a[10];
        BK[11] = a[11];
        BK[12] = a[12];
        BK[13] = a[13];
        BK[14] = a[14];
        BK[15] = a[15];
        return BK;
      },

      p(BK, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
        let BL, BM, BN, BO;
        let BP, BQ, BR, BS;
        let BT, BU, BV, BW;
      
        if (a === BK) {
          BK[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          BK[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          BK[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          BK[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          BL = a[0];
          BM = a[1];
          BN = a[2];
          BO = a[3];
          BP = a[4];
          BQ = a[5];
          BR = a[6];
          BS = a[7];
          BT = a[8];
          BU = a[9];
          BV = a[10];
          BW = a[11];
      
          BK[0] = BL;
          BK[1] = BM;
          BK[2] = BN;
          BK[3] = BO;
          BK[4] = BP;
          BK[5] = BQ;
          BK[6] = BR;
          BK[7] = BS;
          BK[8] = BT;
          BK[9] = BU;
          BK[10] = BV;
          BK[11] = BW;
      
          BK[12] = BL * x + BP * y + BT * z + a[12];
          BK[13] = BM * x + BQ * y + BU * z + a[13];
          BK[14] = BN * x + BR * y + BV * z + a[14];
          BK[15] = BO * x + BS * y + BW * z + a[15];
        }
      
        return BK;
      },

      n(BK, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
      
        BK[0] = a[0] * x;
        BK[1] = a[1] * x;
        BK[2] = a[2] * x;
        BK[3] = a[3] * x;
        BK[4] = a[4] * y;
        BK[5] = a[5] * y;
        BK[6] = a[6] * y;
        BK[7] = a[7] * y;
        BK[8] = a[8] * z;
        BK[9] = a[9] * z;
        BK[10] = a[10] * z;
        BK[11] = a[11] * z;
        BK[12] = a[12];
        BK[13] = a[13];
        BK[14] = a[14];
        BK[15] = a[15];
        return BK;
      },

      q(BK, a, BX, BY) {
        let x = BY[0],
          y = BY[1],
          z = BY[2];
        let BZ = Math.hypot(x, y, z);
        let s, c, t;
        let BL, BM, BN, BO;
        let BP, BQ, BR, BS;
        let BT, BU, BV, BW;
        let Ba, Bb, Bc;
        let Bd, Be, Bf;
        let Bg, Bh, Bi;
      
        if (BZ < BH) {
          return null;
        }
      
        BZ = 1 / BZ;
        x *= BZ;
        y *= BZ;
        z *= BZ;
      
        s = Math.sin(BX);
        c = Math.cos(BX);
        t = 1 - c;
      
        BL = a[0];
        BM = a[1];
        BN = a[2];
        BO = a[3];
        BP = a[4];
        BQ = a[5];
        BR = a[6];
        BS = a[7];
        BT = a[8];
        BU = a[9];
        BV = a[10];
        BW = a[11];
      
        // Bj Bk Bl of Bk m o
        Ba = x * x * t + c;
        Bb = y * x * t + z * s;
        Bc = z * x * t - y * s;
        Bd = x * y * t - z * s;
        Be = y * y * t + c;
        Bf = z * y * t + x * s;
        Bg = x * z * t + y * s;
        Bh = y * z * t - x * s;
        Bi = z * z * t + c;
      
        // Bm m-specific o Bo
        BK[0] = BL * Ba + BP * Bb + BT * Bc;
        BK[1] = BM * Ba + BQ * Bb + BU * Bc;
        BK[2] = BN * Ba + BR * Bb + BV * Bc;
        BK[3] = BO * Ba + BS * Bb + BW * Bc;
        BK[4] = BL * Bd + BP * Be + BT * Bf;
        BK[5] = BM * Bd + BQ * Be + BU * Bf;
        BK[6] = BN * Bd + BR * Be + BV * Bf;
        BK[7] = BO * Bd + BS * Be + BW * Bf;
        BK[8] = BL * Bg + BP * Bh + BT * Bi;
        BK[9] = BM * Bg + BQ * Bh + BU * Bi;
        BK[10] = BN * Bg + BR * Bh + BV * Bi;
        BK[11] = BO * Bg + BS * Bh + BW * Bi;
      
        if (a !== BK) {
          // Bp Bk j Bq Br Bs, Bt Bk Bu Bv Bw
          BK[12] = a[12];
          BK[13] = a[13];
          BK[14] = a[14];
          BK[15] = a[15];
        }
        return BK;
      },

      Bx(BK, a, b) {
        let BL = a[0],
          BM = a[1],
          BN = a[2],
          BO = a[3];
        let BP = a[4],
          BQ = a[5],
          BR = a[6],
          BS = a[7];
        let BT = a[8],
          BU = a[9],
          BV = a[10],
          BW = a[11];
        let By = a[12],
          Bz = a[13],
          CB = a[14],
          CC = a[15];
      
        // CD CE Bk CF CG of Bk CH o
        let CI = b[0],
          CJ = b[1],
          CK = b[2],
          CL = b[3];
        BK[0] = CI * BL + CJ * BP + CK * BT + CL * By;
        BK[1] = CI * BM + CJ * BQ + CK * BU + CL * Bz;
        BK[2] = CI * BN + CJ * BR + CK * BV + CL * CB;
        BK[3] = CI * BO + CJ * BS + CK * BW + CL * CC;
      
        CI = b[4];
        CJ = b[5];
        CK = b[6];
        CL = b[7];
        BK[4] = CI * BL + CJ * BP + CK * BT + CL * By;
        BK[5] = CI * BM + CJ * BQ + CK * BU + CL * Bz;
        BK[6] = CI * BN + CJ * BR + CK * BV + CL * CB;
        BK[7] = CI * BO + CJ * BS + CK * BW + CL * CC;
      
        CI = b[8];
        CJ = b[9];
        CK = b[10];
        CL = b[11];
        BK[8] = CI * BL + CJ * BP + CK * BT + CL * By;
        BK[9] = CI * BM + CJ * BQ + CK * BU + CL * Bz;
        BK[10] = CI * BN + CJ * BR + CK * BV + CL * CB;
        BK[11] = CI * BO + CJ * BS + CK * BW + CL * CC;
      
        CI = b[12];
        CJ = b[13];
        CK = b[14];
        CL = b[15];
        BK[12] = CI * BL + CJ * BP + CK * BT + CL * By;
        BK[13] = CI * BM + CJ * BQ + CK * BU + CL * Bz;
        BK[14] = CI * BN + CJ * BR + CK * BV + CL * CB;
        BK[15] = CI * BO + CJ * BS + CK * BW + CL * CC;
        return BK;
      },


      CM(BK, a) {
        let BL = a[0],
          BM = a[1],
          BN = a[2],
          BO = a[3];
        let BP = a[4],
          BQ = a[5],
          BR = a[6],
          BS = a[7];
        let BT = a[8],
          BU = a[9],
          BV = a[10],
          BW = a[11];
        let By = a[12],
          Bz = a[13],
          CB = a[14],
          CC = a[15];
      
        let Ba = BL * BQ - BM * BP;
        let Bb = BL * BR - BN * BP;
        let Bc = BL * BS - BO * BP;
        let CN = BM * BR - BN * BQ;
        let CO = BM * BS - BO * BQ;
        let CP = BN * BS - BO * BR;
        let CQ = BT * Bz - BU * By;
        let CR = BT * CB - BV * By;
        let CS = BT * CC - BW * By;
        let CT = BU * CB - BV * Bz;
        let Bd = BU * CC - BW * Bz;
        let Be = BV * CC - BW * CB;
      
        // CU Bk CV
        let CW =
          Ba * Be - Bb * Bd + Bc * CT + CN * CS - CO * CR + CP * CQ;
      
        if (!CW) {
          return null;
        }
        CW = 1.0 / CW;
      
        BK[0] = (BQ * Be - BR * Bd + BS * CT) * CW;
        BK[1] = (BN * Bd - BM * Be - BO * CT) * CW;
        BK[2] = (Bz * CP - CB * CO + CC * CN) * CW;
        BK[3] = (BV * CO - BU * CP - BW * CN) * CW;
        BK[4] = (BR * CS - BP * Be - BS * CR) * CW;
        BK[5] = (BL * Be - BN * CS + BO * CR) * CW;
        BK[6] = (CB * Bc - By * CP - CC * Bb) * CW;
        BK[7] = (BT * CP - BV * Bc + BW * Bb) * CW;
        BK[8] = (BP * Bd - BQ * CS + BS * CQ) * CW;
        BK[9] = (BM * CS - BL * Bd - BO * CQ) * CW;
        BK[10] = (By * CO - Bz * Bc + CC * Ba) * CW;
        BK[11] = (BU * Bc - BT * CO - BW * Ba) * CW;
        BK[12] = (BQ * CR - BP * CT - BR * CQ) * CW;
        BK[13] = (BL * CT - BM * CR + BN * CQ) * CW;
        BK[14] = (Bz * Bb - By * CN - CB * Ba) * CW;
        BK[15] = (BT * CN - BU * Bb + BV * Ba) * CW;
      
        return BK;
      },
      
      //perspectiveNO
      i(BK, CY, e, g, h) {
        const CZ = 1.0 / Math.tan(CY / 2);
        BK[0] = CZ / e;
        BK[1] = 0;
        BK[2] = 0;
        BK[3] = 0;
        BK[4] = 0;
        BK[5] = CZ;
        BK[6] = 0;
        BK[7] = 0;
        BK[8] = 0;
        BK[9] = 0;
        BK[11] = -1;
        BK[12] = 0;
        BK[13] = 0;
        BK[15] = 0;
        if (h != null && h !== BI) {
          const Ca = 1 / (g - h);
          BK[10] = (h + g) * Ca;
          BK[14] = 2 * h * g * Ca;
        } else {
          BK[10] = -1;
          BK[14] = -2 * g;
        }
        return BK;
      }


    
    })
    
    node(5,c)
    

}

{

    node(12,function(b,Y,Cb){

      if(Cb===undefined){
        Cb = b.ARRAY_BUFFER
      }
      const Cc = b.createBuffer();
      b.bindBuffer(Cb, Cc);
      b.bufferData(Cb, Y, b.STATIC_DRAW);
      return Cc;

    })
    


    node(13,function(b,Cd,Cc,Ce,Cf,Cb){
      
      if(Cb===undefined){
        Cb=b.ARRAY_BUFFER
      }

      b.bindBuffer(Cb, Cc);

       const Cg = b.getAttribLocation(Cd, Ce);

       if(Cg>-1){
          b.vertexAttribPointer(Cg, Cf, b.FLOAT, false,0,0) ;
          b.enableVertexAttribArray(Cg);
       }

    })

    node(14,function(b,BC){

      const Ch=node(1)
      const Ci=node(2)

      const Cj={}

      for(const BG of Object.keys(BC)){

        if(BG==='BF'){

          Cj[BG] = node(12)(b, Ci(BC[BG]), b.ELEMENT_ARRAY_BUFFER)

        }else{
          Cj[BG] = node(12)(b, Ch(BC[BG]))
        }

      }
      
      return Cj

    })


    node(15,function(b,Cd,Cj){

      const Ck = b.createVertexArray();
      b.bindVertexArray(Ck);

      for(const BG of Object.keys(Cj)){

        let Cl= (BG==='BF')?1:3
        if(BG==='H'){
          Cl=2
        }
        let Cb= (BG==='BF')? b.ELEMENT_ARRAY_BUFFER: b.ARRAY_BUFFER

          node(13)(b,Cd, Cj[BG], BG,Cl,Cb)
            
      }

      b.bindVertexArray(null);

      return Ck

    })



    node(16,function(b,BC,Cd){


      let Cj
      const Cm={
        BC,
        Cj: Cj=node(14)(b, BC),
        Cd,
        Ck: node(15)(b,Cd,Cj),
        Cn:b.TRIANGLES,

        BB(b,z){

            b.useProgram(this.Cd);


           
            b.bindVertexArray(this.Ck);

            
            const Co=node(17)(b,this.Cd)

            Co.set(z)
            Co.set(this.z??{})
            Co.set({
              K:this.o(),
            })
          
          if(this.BC.BF){
            b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this.Cj.BF);

            b.drawElements(this.Cn, this.BC.BF.length, b.UNSIGNED_SHORT, 0);
          }else{
            let Cp=this.BC.F.length/3
            //if(this.Cn===b.POINTS){
            //  Cp=this.BC.F.length/3
            //}
            b.drawArrays(this.Cn, 0, Cp);
          }
        }
      }

      node(7)(Cm)

      return Cm


    })


}

{

    node(18,async function(b,Ce){

      const T=node(0)

        const Cq = await T("/wp-includes/shaders"+"/"+Ce+".vert")
        const Cu = await T("/wp-includes/shaders"+"/"+Ce+".frag")

      return node(19)(b,Cq,Cu)

    })

    node(20,function(b,Cw,Cx){

      const Cy=b.createShader(Cx);
      b.shaderSource(Cy, Cw);
      b.compileShader(Cy);

      if (! b.getShaderParameter(Cy, b.COMPILE_STATUS)) {
        console.log('Cw',Cw)
        console.log(b.getShaderInfoLog(Cy));
      }

      return Cy

    })


    node(19,async function(b,Cq,Cu){

      const Cz = await node(20)(b,Cq,b.VERTEX_SHADER)
      const DB = await node(20)(b,Cu,b.FRAGMENT_SHADER)

      const Cd = b.createProgram();
      b.attachShader(Cd, Cz);
      b.attachShader(Cd, DB);
      b.linkProgram(Cd);

      if (! b.getProgramParameter(Cd, b.LINK_STATUS)) {
        console.log(b.getProgramInfoLog(Cd));
      }

      return Cd

    })

}
{





    node(21,function DC(b, DD) {
        const DE = b.createTexture();
        b.bindTexture(b.TEXTURE_2D, DE);
     
        // DF DG DH DI DJ DK DL Bk DM
        // DN DO DP a DQ DR DN DS DT.
        // DU then DV a DW DX DY Bk DE DZ Da Db
        // Dc Dd De. Df Bk Dg Dh Di Dj
        // Da'Dk Dl Bk DE Dm Bk Dn of Bk Dg.
        const Do = 0;
        const Dp = b.RGBA;
        const width = 1;
        const height = 1;
        const Dq = 0;
        const Dr = b.RGBA;
        const Ds = b.UNSIGNED_BYTE;
        const DX = new Uint8Array([0, 0, 255, 255]);  // Dt Du
        b.texImage2D(b.TEXTURE_2D, Do, Dp,
                    width, height, Dq, Dr, Ds,
                    DX);
     
        const Dg = new Image();
        Dg.onload = function() {
        b.bindTexture(b.TEXTURE_2D, DE);
        b.texImage2D(b.TEXTURE_2D, Do, Dp,
                       Dr, Ds, Dg);
     
        // Dv Dh Dw Dx for Dy of 2 DG
        // Dz EB Dy of 2 DG DZ EC if Bk Dg ED a
        // Dy of 2 DY EE EF.
        if (EG(Dg.width) && EG(Dg.height)) {
           // EH, Dd's a Dy of 2. EI EJ.
           b.generateMipmap(b.TEXTURE_2D);
        } else {
           // EK, Dd's EL a Dy of 2. EM of EJ Bq set
           // EN DI EO DI EP
           b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
           b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
           b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);
        }
        };
        Dg.src = DD;
     
        return DE;
     })
     
     function EG(value) {
        return (value & (value - 1)) == 0;
     }




}{


    node(17,function EQ(b, ER){
       
        let ES=0
        b.activeTexture(b.TEXTURE0)
        b.bindTexture(b.TEXTURE_2D,null)
      
        return {
            set(z){
                
                for(const BG of Object.keys(z)){

                    const Cg = b.getUniformLocation(ER,BG)
                    const ET=z[BG]
                
                    if((! Cg)||(ET===undefined)){
                        return
                    }
                    
                    
                    
                    if((ET!==undefined)&&(ET["constructor"]["name"]==="WebGLTexture")){
                        b.uniform1i(Cg,ES)
                        b.activeTexture(b.TEXTURE0+ES)
                        b.bindTexture(b.TEXTURE_2D,ET)
                        ES++
                    }else{
                        
                        switch(ET.length) {
                            case 16:
                                b.uniformMatrix4fv(Cg,null,ET)
                                break;
                            case 4:
                                b.uniform4fv(Cg,ET)
                                break;
                            case 3:
                                b.uniform3fv(Cg,ET)
                                break;
                            case 2:
                                b.uniform2fv(Cg,ET)
                                break;
                            EU:
                                b.uniform1f(Cg,ET)
                          }
                        

                    }
            
                }
                
            }
        }
    })


}{


    function d(){
        return d.l()
      }

    node(3)(d,{

        l(x,y,z) {
          if(x===undefined){
            x=0.0
          }
          if(y===undefined){
            y=x
          }
          if(z===undefined){
            z=y
          }
          return [x,y,z]
        },

        EV(a){
          let x = a[0];
          let y = a[1];
          let z = a[2];
          return Math.hypot(x, y, z);
        },

        add(BK, a, b) {
          BK[0] = a[0] + b[0];
          BK[1] = a[1] + b[1];
          BK[2] = a[2] + b[2];
          return BK;
        },
        
        EW(BK, a, b) {
          BK[0] = a[0] - b[0];
          BK[1] = a[1] - b[1];
          BK[2] = a[2] - b[2];
          return BK;
        }

    })


    node(6,d)


}{



    node(22,async function(){



        const s=await node(10)()
        const b=s.b



        const EX=5
        function EY(){
            return (EX / 2)-Math.random()*EX
        }

        const EZ=0.2
        function n(){
            return (EZ / 3)+Math.random()*EZ
        }

        const Ea=0.072
        function Eb(){
            return (Ea / 10)+Math.random()*Ea*0.13
        }




        const Cd=await node(18)(b,"default")

        let BC=await node(0)("/wp-includes/models/box.json","json")
        BC=node(11)(BC)

        const B=node(21)(b,"/wp-includes/images/box.webp")

        const Ef=[]

        for(let i=0;i<20;i++){
            const Cm=node(16)(b, BC, Cd)
            Cm.j.k=[EY(), EY(), EY()]
            const EZ=n()
            Cm.j.n=[EZ,EZ,EZ]
            Cm.j.Eb=[Eb(),Eb(),Eb()]

            Cm.z={
                B,
            }

            //mesh.Cn=b.LINE_STRIP;

            Ef.push(Cm)
        }



            for(const Cm of Ef){

                Cm.v=function(x){

                    Cm.j.m=Cm.j.m.map((n,i)=>n+Cm.j.Eb[i])

                }
            }
            //const m=[x*0.3, x*0.12, x*0.45]
            //this.j.m=this.j.m.map((n,i)=>n+m[i])



        s.t.push(...Ef)
















        //node(23)('./models/stickman/scene.Ei')





    })



}
{



    node(24,async function(){



        const s=await node(10)()
        const b=s.b



        

        const Ej=[]
        for(let i=0;i<20;i++){
            Ej.push({point:[Math.random(),Math.random(),0]})
        }


        //const Ek=(Ej.length/3)-2

        console.log('Ej',Ej)

        /*let BZ=1000000;
        let El
        for(const Em of Ej){
            const En=d.EV(Em.Em);
            Em.length=En;
            if(En<len){
                BZ=En;
                El=Em
            }
        }*/
        const Eo=[];

        function Ep(Eq){
            let Er=[];

            for(const Em of Ej){
                const Es=d.EW([],Em.Em,Eq.Em);
                Em.BZ=d.EV(Es);
            }
            let BZ=100000
            let Et
            let Eu
            let Ev
            for(const Em of Ej){
                if(Em!==Eq){
                    if(BZ>point.BZ){
                        BZ=Em.BZ;
                        Ev=Eu;
                        Eu=Et;
                        Et=Em;
                    }
                }
            }

            if(Eq&&point2&&point3){
                Er.push([Eq,Et,Eu])
            }
            if(Et&&point4&&point3){
                Er.push([Et,Ev,Eu])
            }


            return Er;
        }
        
        for(const Em of Ej){
            const Ew=Ep(Em)
            if(Ew.length){
                Eo.push(...Ew);
            }
        }
        //var Ex = Ey.Ez(F);
        //var BD = Ey(Ex.FB, Ex.FC, Ex.EF);
        const F=[]
        for(const FD of Eo){
            F.push(...FD)
        }
        //const BF = Ey(F,null,2);//earcut(F,[4]);
        //console.log('BF',BF)
        //const F=[]
        //for(const p of FE){
        //    F.push(...Eo[p])
        //}
        //const BF=FE

        const Cd=await node(18)(b,"default")
    
        {

            //const F=[]
            //points.map(EY=>positions.push(...EY.Em))

            let BC={positions}
            
            BC=node(11)(BC)

            //const B=node(21)(b,"/wp-includes/images/box.webp")

            

            const Cm=node(16)(b, BC, Cd)

            Cm.Cn=b.POINTS;

            s.t.push(Cm)
        }



        {
            const FF=[]
            Eo.map(FG=>triangle.map(EY=>tpositions.push(...EY.Em)))

            let FH={positions:FF}
            
            FH=node(11)(FH)

            //const B=node(21)(b,"/wp-includes/images/box.webp")

            

            const FI=node(16)(b, FH, Cd)

            //tmesh.Cn=b.LINES;

            s.t.push(FI)
        }
















        //node(23)('./models/stickman/scene.Ei')





    })



}
{



    node(25,async function(){



        const s=await node(10)()
        const b=s.b



        
        //engine.J.j.k = d.l()


        const Cd=await node(18)(b,"render2d")

        let BC=await node(0)("/wp-includes/models/quad.json","json")
        
        BC=node(11)(BC)

        //const B=node(21)(b,"/wp-includes/images/box.webp")

        

        const Cm=node(16)(b, BC, Cd)

        Cm.j.n=[0.8,0.8,0.8]


        s.t.push(Cm)
















        //node(23)('./models/stickman/scene.Ei')





    })



}
{

    node(26,function(){


        //node(25)()

        //node(24)()

        node(22)()


    })

    /*window.addEventListener('FK', () => {
        node(26)()
    })*/

    node(26)()

}

