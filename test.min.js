function node(u,value){
    if(node[u]===undefined){
      node[u]=value
      return false
    }
    return node[u]
}

{

    const v=[]

    node(0,v)

}

{

    const v=node(0)

    function parse(w, x, y, z){
        //let BB = [];
        //let match;
        let BC = y;
        const BD = new RegExp("{{([a-zA-Z0-9]+)}}","gm")
        return BC.replace(BD,match=>{
            const BE=match.substring(2,match["length"]-2)
            w.BE( BE, (BF,BG) => {
                z(BC.replace(new RegExp(match,"gm"),BG));
            });
            return w[BE]
        })
        /*while ((match = BD["exec"](BC)) !== null) {
            BB["push"](match);
        }
        const replace = () => {
            let BH = BC;
            BB.forEach((BI) => {
                const BJ=BI.split('.')
                const BG=w[BI]//(BJ.length?(w[BJ[0]]?(w[BJ[0]][BJ[1]]):undefined):w[BI])
                if (BG !== undefined) {
                    BH = BH.replace("{{" + BI + "}}", BG ?? "");
                }
            });
            if (BH !== BC) {
                z(BH);
            }
        };
        BB.forEach((BI) => {
            w.BE(BI, BG => {
                replace();
            });
        });
        replace();*/
    }
    
    node(1,parse)

    //const parse=node(1)
    
    function BK(BL, w){
        const BM = (x) => {
            const BN = x.getAttributeNames ? x.getAttributeNames() : [];
            BN.forEach((BO) => {
                const BP = x.getAttribute(BO);
                if (BO.indexOf("red-") > -1) {
                    x.removeAttribute(BO);
                    x.BQ = BP;
                    const BR=v[BO["replace"]("red-", "")]
                    if(BR){
                        BR(x, w, BP);
                        //return false
                    }
                } else {
                    parse(w,x, BP, (BS) => {
                        x.setAttribute(BO, BS);
                    });
                    //return true
                }
            })
        };
        function BT(BL){
            const BU = BL
            const x = BL
            if(BU===undefined){
                return
            }
            /*if((!x)||(BV x==="string")){
                return
            }*/
            if (x.nodeName !== "#text") {
                BM(x)
                return
            }
            
            if (x.childNodes.length === 1) {
                parse(w,x, x.innerHTML, (BS) => {
                    x.innerHTML = BS;
                });
            }
            x.childNodes.forEach((node) => {
                BT(node);
            });
        };
        BT(BL);


        /*for(const BM of BW){
            const BX=BL.BY("[red-"+BM.Ba+"]")

            for(const BL of BX){

                const BO=BL.getAttribute("red-"+BM.Ba)

                BM.z(BL,w,BO)

            }
        */
        }


    
    
    node(2,BK)
    //node(0,v)
    //node(1,parse)
    



}

{

    //function BE(){}
    
      /*  Object.prototype.BE = function (Bb, Bc) {
            const Bd = this
            !Bd.Be ? Bd.Be = [] : null;
            !Bd.Be[Bb] ? Bd.Be[Bb] = [] : null
            Bd.Be[Bb]['push'](Bc)
            if (Bd.function hasOwnProperty() { [native code] }(Bb) && !Bd.function hasOwnProperty() { [native code] }('_' + Bb)) {
                Bd['_' + Bb] = Bd[Bb]
                try{
                //delete(Bd[Bb])
                }catch(e){}
            }
            if (!Bd.function hasOwnProperty() { [native code] }(Bb)) {
                Object.Bg(Bd, Bb, {
                    ["get"]: () => Bd['_' + Bb],
                    ["set"]: (value) => {
                        const Bh=Bd['_' + Bb]
                        Bd.Be[Bb].forEach(Bc => {
                            Bc(Bh,value)
                        })
                        Bd['_' + Bb] = value
                    },
                })
            }
        }*/
    
    
        ///////////////////////////////////////////
    
    
      
    
            Object.prototype.BE = function (Bb, Bc) {
    
                let Bi = this.Bi
                if(Bi===undefined){
                    Bi={}
                    this.Bi = Bi
                }
                if(Bi[Bb]===undefined){
                    Bi[Bb]= {
                        Bj:[],
                        Bk:this[Bb],
                    }
                }
    
                Bi[Bb].Bj.push(Bc)
    
            if (!this["hasOwnProperty"](Bb)) {

                Object["defineProperty"](this, Bb, {
    
                    ["get"]: () => Bi[Bb].Bk,
                    ["set"]: (BG) => {
                            
                            for(const Bc of Bi[Bb].Bj){
                                Bc(Bi[Bb].Bk,BG)
                            }
                            Bi[Bb].Bk = BG
                        },
    
                })
            }
          
            }
    
    
    //}

}



{

    const v=node(0)
    
    function Bl(BL, w, BO){
        BL.addEventListener("click",(Bm) => {
            return (function (Bn) {
                return eval(Bn)
            }.bind(w))(BO)
        });
    }
    
    v["click"]=Bl
    

}



{

    
    /*Bo*/
    
    /*Bp*/
    node(3,function(Bq,Br){
      return Object.assign(Bq,Br)
    })
    
    node(4,async function Bs(Bt,Bu){
        const Bv=await fetch(Bt)
        const BC=await Bv[Bu??"text"]()
        return BC
    })

    node(5,function(Bw){
      return new Uint8Array(Bw)
    })
    
    node(6,function(Bw){
      return new Float32Array(Bw)
    })
    
    node(7,function(Bw){
      return new Uint16Array(Bw)
    })
    

}



{

    

    node(8,function(Bx){

      const By=node(9)
    const Bz=node(10)

    const CB=Bx.canvas.width / Bx.canvas.height;

        const J={
            CC: 5*9,
            CB,
            CD: 1/1000,
            CE: 100,

            I(){
              return By.CF([], this.CC, this.CB, this.CD, this.CE)
            }
          }
        

        node(11)(J)

        return J


    })


}

{

    node(12,function(Bx){

        Bx.enable(Bx.DEPTH_TEST);
        Bx.depthFunc(Bx.LEQUAL);
        Bx.clearColor(0.0, 0.0, 0.0, 0.0);
        Bx.clearDepth(10.0);

    })

    node(13,function(Bx,CG){

        const CH=CG ? CG.CI:null;
        Bx.bindFramebuffer(Bx.FRAMEBUFFER, CH);

        const clearColor=(CG && CG.clearColor) ? CG.clearColor:[0.0, 0.0, 0.0, 0.0];
        Bx.clearColor(...clearColor);

        if(CG){
            Bx.viewport(0.0, 0.0, CG.width, CG.height);
        }else{
            Bx.viewport(0.0, 0.0, Bx.canvas.width, Bx.canvas.height);
        }
        Bx.clear(Bx.COLOR_BUFFER_BIT | Bx.DEPTH_BUFFER_BIT);


    })


    node(11,function(Bq){

        const By=node(9)
        const Bz=node(10)

        return Object.assign(Bq,{

            y: Bq.y??node(14)(),
            CJ(){
                const CJ=By.CK()
                By.CL(CJ, CJ, this.y.CM);
                By.CN(CJ, CJ, this.y.CO[2], [0,0,1]);
                By.CN(CJ, CJ, this.y.CO[1], [0,1,0]);
                By.CN(CJ, CJ, this.y.CO[0], [1,0,0]);
                By.CP(CJ, CJ, this.y.CP);
                return CJ
            }

        })


    })


    node(15,function(Bq){

        node(3)(Bq,{

            CQ:[],

            CR(...CS){

                if(this.CQ){
                    for(const CT of this.CQ){
                        CT.CR(...CS)
                    }
                }

                if(this.CU){
                    this.CU(...CS)
                }

            },

            CV(CW=By.CK()) {
              
                this.CX=this.CJ();
          
                By.CY(this.CX, CW, this.CX);
          
                for (const CT of this.CQ) {
                    CT.CV(this.CX);
                }
            },

        })

    })


    node(14,function( CM =[0,0,0], CO=[0,0,0], CP=[1,1,1]){
        return { CM , CO, CP}
    })


    node(16,function(y=node(14),CZ='Ca CZ'){
        const Ca={name,y,
            add(Ca){
                this.CQ.push(Ca)
            }
        }
        node(11)(Ca)
        node(15)(Ca)
        return Ca
    })


}

node(17,function(Bx,width,height){

    const CG={
      width,
      height,
      //renderbuffer: Bx.createRenderbuffer(),
      CI: Bx.createFramebuffer(),
      L: node(18)(Bx,undefined,width,height,'L'),
      Q: node(18)(Bx,undefined,width,height,'Q'),
    }


    //gl.bindRenderbuffer(Bx.RENDERBUFFER, CG.Cb);
    //gl.renderbufferStorage(Bx.RENDERBUFFER, Bx.DEPTH_COMPONENT24, width,height);

    // CI
    Bx.bindFramebuffer(Bx.FRAMEBUFFER, CG.CI);
    CG.CI.width = width;
    CG.CI.height = height;

    // Cc
    //gl.bindTexture(Bx.TEXTURE_2D, CG.L);
    /*Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MAG_FILTER, Bx.LINEAR);
    Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MIN_FILTER, Bx.LINEAR);
    Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_S, Bx.CLAMP_TO_EDGE);
    Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_T, Bx.CLAMP_TO_EDGE);*/
    //gl.texImage2D(Bx.TEXTURE_2D, 0, Bx.RGBA, CG.CI.width, CG.CI.height, 0, Bx.RGBA, Bx.UNSIGNED_BYTE, null);

    // Cd
    //gl.bindTexture(Bx.TEXTURE_2D, CG.Q);
    /*Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MAG_FILTER, Bx.LINEAR);
    Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MIN_FILTER, Bx.LINEAR);
    Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_S, Bx.CLAMP_TO_EDGE);
    Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_T, Bx.CLAMP_TO_EDGE);*/
    //gl.texImage2D(Bx.TEXTURE_2D, 0, Bx.DEPTH_COMPONENT24, CG.CI.width, CG.CI.height, 0, Bx.DEPTH_COMPONENT, Bx.UNSIGNED_INT, null);

    // Ce Cf
    Bx.framebufferTexture2D(Bx.FRAMEBUFFER, Bx.COLOR_ATTACHMENT0, Bx.TEXTURE_2D, CG.L, 0);
    Bx.framebufferTexture2D(Bx.FRAMEBUFFER, Bx.DEPTH_ATTACHMENT, Bx.TEXTURE_2D, CG.Q, 0);

    //gl.framebufferRenderbuffer(Bx.FRAMEBUFFER, Bx.DEPTH_ATTACHMENT, Bx.RENDERBUFFER, CG.Cb);

    //this.Cg();

    Bx.bindTexture(Bx.TEXTURE_2D, null);
    Bx.bindRenderbuffer(Bx.RENDERBUFFER, null);
    Bx.bindFramebuffer(Bx.FRAMEBUFFER, null);

    return CG

})

{
  
    node(19,function(){
        const canvas=document.createElement('canvas')
        canvas.width=window.innerWidth
        canvas.height=window.innerHeight
        document.body.append(canvas)
        return canvas
    })

}

{




    node(20,async function(canvas=node(19)() ){

      

      //if(canvas===undefined){
        /*canvas=document.createElement('canvas')
        canvas.width=window.innerWidth
        canvas.height=window.innerHeight
        document.body.append(canvas)*/
        //canvas=node(19)()
      //}
      const Bx = canvas.getContext("webgl2")

      //var Ch = Bx.getExtension('Ci');

      const Cj={
        Bx,
        Ck:[],
        add(Ca){
            this.Ck.push(Ca)
        }
      }
      


  

    Cj.Cf=[]

    const Cl=node(17)(Bx,512,512)
    Cj.Cf.push(Cl)

    const Cm=node(17)(Bx,512,512)
    Cm.Cn=await node(21)(Bx,"depth")
    Cm.clearColor=[0,0,0,1]
    Cj.Cf.push(Cm)


    /*const Co=node(22);

    var Cp=0, width=25
    var x=-(((Cp-100)/100)*2)-1, Cr=(width/100)*2
    const Cs = await Co(Cj, 1,0.5, -x, -x+Cr)*/

    /*var Cp=25, width=25
    var x=-(((Cp-100)/100)*2)-1, Cr=(width/100)*2
    this.Ct = new Cu(this, 1,0.5, -x, -x+Cr)

    var Cp=50, width=25
    var x=-(((Cp-100)/100)*2)-1, Cr=(width/100)*2
    this.Cv = new Cu(this, 1,0.5, -x, -x+Cr)



    var Cp=50, width=50
    var x=-(((Cp-100)/100)*2)-1, Cr=(width/100)*2
    this.Cw = new Cu(this, 0.0,-1.0, -x, -x+Cr)*/


    const Cx=node(23)(Bx,"/images/box.webp")

    Cj.DC=[]

      const DD=await node(24)(Cj)
      DD.y.CP=Bz(1.0)//[0.5,0.5,0.5]
      //render2d.y.CM=[0.0,0.0,0]
      DD.DE.d=Cl.L
      DD.DE.e=Cm.L
      Cj.DC.push(DD)

      /*const DF=await node(24)(Cj)
      DF.y.CP=[0.5,0.5,0.5]
      DF.y.CM=[0,0.5,0]
      DF.DE.d=CG.Q
      Cj.DC.push(DF)*/

      ///render2d.DE.d=B
      //engine.Ck.push(DD)


    //const d=B//buffer.L




    //gl.enable(Bx.CULL_FACE);
    Bx.enable(Bx.DEPTH_TEST);
    Bx.depthFunc(Bx.LEQUAL);
    //gl.colorMask(true, true, true, false);//.DG() 
    //gl.depthFunc(Bx.LEQUAL);

    //gl.blendFunc(Bx.SRC_ALPHA, Bx.ONE_MINUS_SRC_ALPHA);
    //gl.enable(Bx.BLEND);








    const J=node(8)(Bx)
    J.y.CM[2] = -6

    Cj.J=J



      function CR(Bx, DE, DH, Cn){

        for(const K of Cj.Ck){
  
          if(K.DI){
            K.DI(DH)
          }
  
          if(!K.CR){
              console.log('K DJ CR()...', K)
          }
          K.CR(Bx, DE, DH, Cn)
  
       }
  
      }

      console.log('Cj',Cj);

    node(12)(Bx)

    var DK = 0;
    let DL=0;

    var DI = function(DM) {


       const DH = (DM-DK)*0.001;
       DL++;



       DK = DM;


        const DE={
            I: J.I(),
            J: J.CJ(),
            R:J.y.CM,
            a:J.y.CM,
            V:[Bx.canvas.width,Bx.canvas.height],
            W:DM,
            X:DH,
            DL:DL,
            f:Cx,
        }


        for (const Ca of Cj.Ck) {
          Ca.CV();
          if(Ca.DO){
            Ca.DP(X);
          }
        }

      //for(const DQ of this.DR){
      //  DQ.bind(this)(X)
      //}


        for(const CG of Cj.Cf){
            node(13)(Bx,CG)
            CR(Bx, DE, DH, CG.Cn)
        }

        node(13)(Bx)
        CR(Bx, DE, DH)//, Cm.Cn)
        

        //render2d.DE.d=CG.L//colorTexture
        //print.CR(Bx,DE)
        for(const CR of Cj.DC){
            CR.CR(Bx,DE)
        }




       requestAnimationFrame(DI);


    }
    DI(0);

    return Cj

    })



}


{


        node(25,function(DS){
            

            const DT={}

            const DU=["positions", "normals", "texcoords", "indices"]


            if(DS[DU[0]]){
                DT.F=DS[DU[0]]
            }
            if(DS[DU[1]]){
                DT.G=DS[DU[1]]
            }
            if(DS[DU[2]]){
                DT.H=DS[DU[2]]
            }
            if(DS[DU[3]]){
                DT.DV=DS[DU[3]]
            }



            for(const DW of Object.keys(DS)){
                if(! DU.includes(DW)){
                    DT[DW]=DS[DW]
                }
            }

            return DT


        })



}

{

  const DX = 0.000001;
  const DY =  1/ DX;

    function By(){
      return By.CK()
    }



    node(3)(By,{

      CK() {
        return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1]
      },
      
      DZ(a) {
        let Da = [];
        Da[0] = a[0];
        Da[1] = a[1];
        Da[2] = a[2];
        Da[3] = a[3];
        Da[4] = a[4];
        Da[5] = a[5];
        Da[6] = a[6];
        Da[7] = a[7];
        Da[8] = a[8];
        Da[9] = a[9];
        Da[10] = a[10];
        Da[11] = a[11];
        Da[12] = a[12];
        Da[13] = a[13];
        Da[14] = a[14];
        Da[15] = a[15];
        return Da;
      },

      CL(Da, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
        let Db, Dc, Dd, De;
        let Df, Dg, Dh, Di;
        let Dj, Dk, Dl, Dm;
      
        if (a === Da) {
          Da[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          Da[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          Da[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          Da[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          Db = a[0];
          Dc = a[1];
          Dd = a[2];
          De = a[3];
          Df = a[4];
          Dg = a[5];
          Dh = a[6];
          Di = a[7];
          Dj = a[8];
          Dk = a[9];
          Dl = a[10];
          Dm = a[11];
      
          Da[0] = Db;
          Da[1] = Dc;
          Da[2] = Dd;
          Da[3] = De;
          Da[4] = Df;
          Da[5] = Dg;
          Da[6] = Dh;
          Da[7] = Di;
          Da[8] = Dj;
          Da[9] = Dk;
          Da[10] = Dl;
          Da[11] = Dm;
      
          Da[12] = Db * x + Df * y + Dj * z + a[12];
          Da[13] = Dc * x + Dg * y + Dk * z + a[13];
          Da[14] = Dd * x + Dh * y + Dl * z + a[14];
          Da[15] = De * x + Di * y + Dm * z + a[15];
        }
      
        return Da;
      },

      CP(Da, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
      
        Da[0] = a[0] * x;
        Da[1] = a[1] * x;
        Da[2] = a[2] * x;
        Da[3] = a[3] * x;
        Da[4] = a[4] * y;
        Da[5] = a[5] * y;
        Da[6] = a[6] * y;
        Da[7] = a[7] * y;
        Da[8] = a[8] * z;
        Da[9] = a[9] * z;
        Da[10] = a[10] * z;
        Da[11] = a[11] * z;
        Da[12] = a[12];
        Da[13] = a[13];
        Da[14] = a[14];
        Da[15] = a[15];
        return Da;
      },

      CN(Da, a, Dn, Do) {
        let x = Do[0],
          y = Do[1],
          z = Do[2];
        let Dp = Math.hypot(x, y, z);
        let s, c, t;
        let Db, Dc, Dd, De;
        let Df, Dg, Dh, Di;
        let Dj, Dk, Dl, Dm;
        let Dq, Dr, Ds;
        let Dt, Du, Dv;
        let Dw, Dx, Dy;
      
        if (Dp < DX) {
          return null;
        }
      
        Dp = 1 / Dp;
        x *= Dp;
        y *= Dp;
        z *= Dp;
      
        s = Math.sin(Dn);
        c = Math.cos(Dn);
        t = 1 - c;
      
        Db = a[0];
        Dc = a[1];
        Dd = a[2];
        De = a[3];
        Df = a[4];
        Dg = a[5];
        Dh = a[6];
        Di = a[7];
        Dj = a[8];
        Dk = a[9];
        Dl = a[10];
        Dm = a[11];
      
        // Dz EB BX of EB CO CJ
        Dq = x * x * t + c;
        Dr = y * x * t + z * s;
        Ds = z * x * t - y * s;
        Dt = x * y * t - z * s;
        Du = y * y * t + c;
        Dv = z * y * t + x * s;
        Dw = x * z * t + y * s;
        Dx = y * z * t - x * s;
        Dy = z * z * t + c;
      
        // EC CO-specific CJ EE
        Da[0] = Db * Dq + Df * Dr + Dj * Ds;
        Da[1] = Dc * Dq + Dg * Dr + Dk * Ds;
        Da[2] = Dd * Dq + Dh * Dr + Dl * Ds;
        Da[3] = De * Dq + Di * Dr + Dm * Ds;
        Da[4] = Db * Dt + Df * Du + Dj * Dv;
        Da[5] = Dc * Dt + Dg * Du + Dk * Dv;
        Da[6] = Dd * Dt + Dh * Du + Dl * Dv;
        Da[7] = De * Dt + Di * Du + Dm * Dv;
        Da[8] = Db * Dw + Df * Dx + Dj * Dy;
        Da[9] = Dc * Dw + Dg * Dx + Dk * Dy;
        Da[10] = Dd * Dw + Dh * Dx + Dl * Dy;
        Da[11] = De * Dw + Di * Dx + Dm * Dy;
      
        if (a !== Da) {
          // EF EB y EG EH EI, EJ EB EK EL EM
          Da[12] = a[12];
          Da[13] = a[13];
          Da[14] = a[14];
          Da[15] = a[15];
        }
        return Da;
      },

      CY(Da, a, b) {
        let Db = a[0],
          Dc = a[1],
          Dd = a[2],
          De = a[3];
        let Df = a[4],
          Dg = a[5],
          Dh = a[6],
          Di = a[7];
        let Dj = a[8],
          Dk = a[9],
          Dl = a[10],
          Dm = a[11];
        let EN = a[12],
          EO = a[13],
          EP = a[14],
          EQ = a[15];
      
        // ER ES EB ET EU of EB EV CJ
        let EW = b[0],
          EX = b[1],
          EY = b[2],
          EZ = b[3];
        Da[0] = EW * Db + EX * Df + EY * Dj + EZ * EN;
        Da[1] = EW * Dc + EX * Dg + EY * Dk + EZ * EO;
        Da[2] = EW * Dd + EX * Dh + EY * Dl + EZ * EP;
        Da[3] = EW * De + EX * Di + EY * Dm + EZ * EQ;
      
        EW = b[4];
        EX = b[5];
        EY = b[6];
        EZ = b[7];
        Da[4] = EW * Db + EX * Df + EY * Dj + EZ * EN;
        Da[5] = EW * Dc + EX * Dg + EY * Dk + EZ * EO;
        Da[6] = EW * Dd + EX * Dh + EY * Dl + EZ * EP;
        Da[7] = EW * De + EX * Di + EY * Dm + EZ * EQ;
      
        EW = b[8];
        EX = b[9];
        EY = b[10];
        EZ = b[11];
        Da[8] = EW * Db + EX * Df + EY * Dj + EZ * EN;
        Da[9] = EW * Dc + EX * Dg + EY * Dk + EZ * EO;
        Da[10] = EW * Dd + EX * Dh + EY * Dl + EZ * EP;
        Da[11] = EW * De + EX * Di + EY * Dm + EZ * EQ;
      
        EW = b[12];
        EX = b[13];
        EY = b[14];
        EZ = b[15];
        Da[12] = EW * Db + EX * Df + EY * Dj + EZ * EN;
        Da[13] = EW * Dc + EX * Dg + EY * Dk + EZ * EO;
        Da[14] = EW * Dd + EX * Dh + EY * Dl + EZ * EP;
        Da[15] = EW * De + EX * Di + EY * Dm + EZ * EQ;
        return Da;
      },


      Ea(Da, a) {
        let Db = a[0],
          Dc = a[1],
          Dd = a[2],
          De = a[3];
        let Df = a[4],
          Dg = a[5],
          Dh = a[6],
          Di = a[7];
        let Dj = a[8],
          Dk = a[9],
          Dl = a[10],
          Dm = a[11];
        let EN = a[12],
          EO = a[13],
          EP = a[14],
          EQ = a[15];
      
        let Dq = Db * Dg - Dc * Df;
        let Dr = Db * Dh - Dd * Df;
        let Ds = Db * Di - De * Df;
        let Eb = Dc * Dh - Dd * Dg;
        let Ec = Dc * Di - De * Dg;
        let Ed = Dd * Di - De * Dh;
        let Ee = Dj * EO - Dk * EN;
        let Ef = Dj * EP - Dl * EN;
        let Eg = Dj * EQ - Dm * EN;
        let Eh = Dk * EP - Dl * EO;
        let Dt = Dk * EQ - Dm * EO;
        let Du = Dl * EQ - Dm * EP;
      
        // Ei EB Ej
        let Ek =
          Dq * Du - Dr * Dt + Ds * Eh + Eb * Eg - Ec * Ef + Ed * Ee;
      
        if (!Ek) {
          return null;
        }
        Ek = 1.0 / Ek;
      
        Da[0] = (Dg * Du - Dh * Dt + Di * Eh) * Ek;
        Da[1] = (Dd * Dt - Dc * Du - De * Eh) * Ek;
        Da[2] = (EO * Ed - EP * Ec + EQ * Eb) * Ek;
        Da[3] = (Dl * Ec - Dk * Ed - Dm * Eb) * Ek;
        Da[4] = (Dh * Eg - Df * Du - Di * Ef) * Ek;
        Da[5] = (Db * Du - Dd * Eg + De * Ef) * Ek;
        Da[6] = (EP * Ds - EN * Ed - EQ * Dr) * Ek;
        Da[7] = (Dj * Ed - Dl * Ds + Dm * Dr) * Ek;
        Da[8] = (Df * Dt - Dg * Eg + Di * Ee) * Ek;
        Da[9] = (Dc * Eg - Db * Dt - De * Ee) * Ek;
        Da[10] = (EN * Ec - EO * Ds + EQ * Dq) * Ek;
        Da[11] = (Dk * Ds - Dj * Ec - Dm * Dq) * Ek;
        Da[12] = (Dg * Ef - Df * Eh - Dh * Ee) * Ek;
        Da[13] = (Db * Eh - Dc * Ef + Dd * Ee) * Ek;
        Da[14] = (EO * Dr - EN * Eb - EP * Dq) * Ek;
        Da[15] = (Dj * Eb - Dk * Dr + Dl * Dq) * Ek;
      
        return Da;
      },
      
      //perspectiveNO
      CF(Da, Em, CB, CD, CE) {
        const En = 1.0 / Math.tan(Em / 2);
        Da[0] = En / CB;
        Da[1] = 0;
        Da[2] = 0;
        Da[3] = 0;
        Da[4] = 0;
        Da[5] = En;
        Da[6] = 0;
        Da[7] = 0;
        Da[8] = 0;
        Da[9] = 0;
        Da[11] = -1;
        Da[12] = 0;
        Da[13] = 0;
        Da[15] = 0;
        if (CE != null && CE !== DY) {
          const Eo = 1 / (CD - CE);
          Da[10] = (CE + CD) * Eo;
          Da[14] = 2 * CE * CD * Eo;
        } else {
          Da[10] = -1;
          Da[14] = -2 * CD;
        }
        return Da;
      }


    
    })
    
    node(9,By)
    

}



{

    node(26,function(Bx,Bw,Ep){

      if(Ep===undefined){
        Ep = Bx.ARRAY_BUFFER
      }
      const CG = Bx.createBuffer();
      Bx.bindBuffer(Ep, CG);
      Bx.bufferData(Ep, Bw, Bx.STATIC_DRAW);
      return CG;

    })
    


    node(27,function(Bx,Cn,CG,CZ,Eq,Ep){
      
      if(Ep===undefined){
        Ep=Bx.ARRAY_BUFFER
      }

      Bx.bindBuffer(Ep, CG);

       const CH = Bx.getAttribLocation(Cn.Er, CZ);

       if(CH>-1){
         if(CZ==='Es'){
          Bx.vertexAttribIPointer(CH, Eq, Bx.UNSIGNED_SHORT, false,0,0) ;
         }else{
          Bx.vertexAttribPointer(CH, Eq, Bx.FLOAT, false,0,0) ;
         }
        Bx.enableVertexAttribArray(CH);
       }

    })

    node(28,function(Bx,DS){

      const Et=node(6)
      const Eu=node(7)

      const Cf={}

      for(const DW of Object.keys(DS)){

        if(DW==='DV'){

          Cf[DW] = node(26)(Bx, Eu(DS[DW]), Bx.ELEMENT_ARRAY_BUFFER)

        }else{
          Cf[DW] = node(26)(Bx, Et(DS[DW]))
        }

      }
      
      return Cf

    })


    node(29,function(Bx,Cn,Cf){

      const Ev = Bx.createVertexArray();
      Bx.bindVertexArray(Ev);

      for(const DW of Object.keys(Cf)){

        let Ew= (DW==='DV')?1:3
        if(DW==='H'){
          Ew=2
        }
        let Ep= (DW==='DV')? Bx.ELEMENT_ARRAY_BUFFER: Bx.ARRAY_BUFFER

          node(27)(Bx,Cn, Cf[DW], DW,Ew,Ep)
            
      }

      Bx.bindVertexArray(null);

      return Ev

    })

    node(30,function(...CS){
      return node(31)(...CS)
    })

    node(31,function(Cj,DS,Cn,Ex=true){

      const Bx=Cj.Bx


      let Cf
      const Ey={
        DS,
        Cf: Cf=node(28)(Bx, DS),
        Cn,
        Ev: node(29)(Bx,Cn,Cf),
        Ez:Bx.TRIANGLES,
        DE:{},

        CU(Bx,DE,DH,Cn){

            Cn=Cn ?? this.Cn

            Bx.useProgram(Cn.Er);


           
            Bx.bindVertexArray(this.Ev);

            
            const FB=node(32)(Bx,Cn)

            FB.set(DE)
            FB.set(this.DE??{})
            FB.set({
              K:this.CX??this.CJ(),
            })
          
          if(this.DS.DV){
            Bx.bindBuffer(Bx.ELEMENT_ARRAY_BUFFER, this.Cf.DV);

            Bx.drawElements(this.Ez, this.DS.DV.length, Bx.UNSIGNED_SHORT, 0);
          }else{
            let k=this.DS.F.length/3
            //if(this.Ez===Bx.POINTS){
            //  k=this.DS.F.length/3
            //}
            Bx.drawArrays(this.Ez, 0, k);
          }
        }
      }

      node(11)(Ey)
      node(15)(Ey)

      if(Ex){
          Cj.add(Ey)
      }

      return Ey


    })


}



{

    node(21,async function(Bx,CZ){

      const Cn={
        CZ,
      }

      const Bs=node(4)

      let FC="/shaders"//-min"
      //try{
      //  if(FF!==undefined){
      //    FC="/shaders"
      //  }
      //}catch(e){}

      const FG = await Bs(FC+"/"+CZ+".vert")
      const FI = await Bs(FC+"/"+CZ+".frag")

      Cn.Er = await node(33)(Bx,FG,FI)

      return Cn

    })

    node(34,function(Bx,FK,FL){

      const Cn=Bx.createShader(FL);
      Bx.shaderSource(Cn, FK);
      Bx.compileShader(Cn);

      if (! Bx.getShaderParameter(Cn, Bx.COMPILE_STATUS)) {
        console.log('FK',FK)
        console.log(Bx.getShaderInfoLog(Cn));
      }

      return Cn

    })


    node(33,async function(Bx,FG,FI){

      const FM = await node(34)(Bx,FG,Bx.VERTEX_SHADER)
      const FN = await node(34)(Bx,FI,Bx.FRAGMENT_SHADER)

      const FO = Bx.createProgram();
      Bx.attachShader(FO, FM);
      Bx.attachShader(FO, FN);
      Bx.linkProgram(FO);

      if (! Bx.getProgramParameter(FO, Bx.LINK_STATUS)) {
        console.log(Bx.getProgramInfoLog(FO));
      }

      return FO

    })

}


{

   function FP(value) {
      return (value & (value - 1)) == 0;
   }

   node(35,function(Bx,FQ,width=1,height=1,FR='FS'){
        Bx.bindTexture(Bx.TEXTURE_2D, FQ);

        if(FP(width) && FP(height) && (FR!=='Q') ) {
            Bx.generateMipmap(Bx.TEXTURE_2D);
        } else {
            const FT=(FR==='Q') ? Bx.NEAREST:Bx.LINEAR;
            Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MAG_FILTER, FT);
            Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MIN_FILTER, FT);
            if(FR!=='Q'){
                Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_S, Bx.CLAMP_TO_EDGE);
                Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_T, Bx.CLAMP_TO_EDGE);
            }
        }
   })

   node(18,function(Bx,L=[0, 0, 255, 255],width=1,height=1,FR='FS'){
      const FQ = Bx.createTexture();
      Bx.bindTexture(Bx.TEXTURE_2D, FQ);

      if(FR==='FS'){
        const h = node(5)(L)
        Bx.texImage2D(Bx.TEXTURE_2D, 0, Bx.RGBA, width, height, 0, Bx.RGBA, Bx.UNSIGNED_BYTE, h);
      }else if(FR==='L'){
        Bx.texImage2D(Bx.TEXTURE_2D, 0, Bx.RGBA, width, height, 0, Bx.RGBA, Bx.UNSIGNED_BYTE, null);
      }else if(FR==='Q'){
        Bx.texImage2D(Bx.TEXTURE_2D, 0, Bx.DEPTH_COMPONENT24, width, height, 0, Bx.DEPTH_COMPONENT, Bx.UNSIGNED_INT, null);
      }

      node(35)(Bx,FQ,width,height,FR)

      return FQ;
   })


    node(23,function FU(Bx, FV) {
        const FQ=node(18)(Bx)
 
        const FW = new Image();
        FW.onload = function() {
            Bx.bindTexture(Bx.TEXTURE_2D, FQ);
            Bx.texImage2D(Bx.TEXTURE_2D, 0, Bx.RGBA, Bx.RGBA, Bx.UNSIGNED_BYTE, FW);
         
            node(35)(Bx,FQ,FW.width,FW.height)
        };
        FW.src = FV;
     
        return FQ;
     })



}

{


    node(32,function FX(Bx,Cn){
       
        let FY=0
        Bx.activeTexture(Bx.TEXTURE0)
        Bx.bindTexture(Bx.TEXTURE_2D,null)
      
        return {
            set(DE){
                
                for(const DW of Object.keys(DE)){

                    const CH = Bx.getUniformLocation(Cn.Er,DW)
                    const Bk=DE[DW]
                
                    if((! CH)||(Bk===undefined)){
                        return
                    }
                    
                    
                    
                    if((Bk!==undefined)&&(Bk["constructor"]["name"]==="WebGLTexture")){
                        Bx.uniform1i(CH,FY)
                        Bx.activeTexture(Bx.TEXTURE0+FY)
                        Bx.bindTexture(Bx.TEXTURE_2D,Bk)
                        FY++
                    }else{
                        
                        switch(Bk.length) {
                            case 16:
                                Bx.uniformMatrix4fv(CH,null,Bk)
                                break;
                            case 4:
                                Bx.uniform4fv(CH,Bk)
                                break;
                            case 3:
                                Bx.uniform3fv(CH,Bk)
                                break;
                            case 2:
                                Bx.uniform2fv(CH,Bk)
                                break;
                            FS:
                                Bx.uniform1f(CH,Bk)
                          }
                        

                    }
            
                }
                
            }
        }
    })


}

{


    function Bz(FZ){
        return Bz.CK(FZ)
      }

    node(3)(Bz,{

        CK(x,y,z) {
          if(x===undefined){
            x=0.0
          }
          if(y===undefined){
            y=x
          }
          if(z===undefined){
            z=y
          }
          return [x,y,z]
        },

        Fa(a){
          let x = a[0];
          let y = a[1];
          let z = a[2];
          return Math.hypot(x, y, z);
        },

        add(Da, a, b) {
          Da[0] = a[0] + b[0];
          Da[1] = a[1] + b[1];
          Da[2] = a[2] + b[2];
          return Da;
        },
        
        Fb(Da, a, b) {
          Da[0] = a[0] - b[0];
          Da[1] = a[1] - b[1];
          Da[2] = a[2] - b[2];
          return Da;
        }

    })


    node(10,Bz)


}

{



    node(24,async function(Cj){



        //const Cj=await node(20)()
        const Bx=Cj.Bx



        
        //engine.J.y.CM = Bz.CK()


        const FO=await node(21)(Bx,"render2d")

        let DS=await node(4)("/models/quad.json","json")
        
        DS=node(25)(DS)

        //const B=node(23)(Bx,"/wp-includes/images/box.webp")
        //const B=node(23)(Bx,"/images/box.webp")
        

        const Ey=node(30)(Cj, DS, FO, false)

        

        /*const DE={
            //colorTexture:B,
        }


        const CR={
            DE,
            CR(Bx,DE){
                node(3)(Ey.DE,this.DE)
                //mesh.DE=this.DE;
                Ey.CR(Bx,DE)
            }
        }*/

        //mesh.DE.d=d


        //engine.Ck.push(CR)



        return Ey












        //node(36)('./models/stickman/scene.Fg')





    })



}


    {
        
        function Fh(BG){
            return {
                '5120': Fi,
                '5121': Uint8Array,
                '5122': Fj,
                '5123': Uint16Array,
                '5124': Fk,
                '5125': Fl,
                '5126': Float32Array
            }[BG]
        }
        
        function Fm(BG){
            return {
                'Fn': 1,
                'Fo': 2,
                'Fp': 3,
                'Fq': 4,
                'Fr': 4,
                'Fs': 9,
                'Ft': 16
            }[BG]
        }
        
        function Fu(Fg, Fv) {
            const Fw = Fg.Fx[Fv];
            const Fy = Fg.Fz[Fw.Fy];
            const GB = Fh(Fw.GC);
            const CG = Fg.Cf[Fy.CG];
            Fw.Eq=Fm(Fw.Bu)
            const Bw=new GB(
              CG,
              Fy.GD + (Fw.GD || 0),
              Fw.k * Fw.Eq)
            return Bw/*{
              Fw,
              Bw,
          }*/
        }
        
        
        
        node(36,async function(Cj,Bt){
        
            const Bx=Cj.Bx
        
            //const Cn=await node(34)('GE.FH','GE.FJ')
            //const GF=await node(34)('GE')
            const Cn=await node(21)(Bx,"skin")
        
            
            let FC=Bt.replace(Bt.split('/').pop(),'')
        
            const Fg=await node(4)(Bt,"json")
        
            //console.log(Fg)
        
            for(const DW of Object.keys(Fg.Cf)){
                const FV=FC+'/'+Fg.Cf[DW].Bt
                Fg.Cf[DW]=await node(4)(FV,'GG')
            }
        
            
        
            Fg.Fx=Fg.Fx.map((Fw,GH)=>{
                return Fu(Fg,GH)
            })
        
            Fg.Cy=(Fg.Cy??[]).map(FW=>{
                return node(23)(Bx, FC+'/'+FW.Bt)
            })
        
            Fg.GI=(Fg.GI??[]).map(FQ=>{
                return Fg.Cy[FQ.y]
            })
        
            Fg.GJ=(Fg.GJ??[]).map(GK=>{
                const GL={}
                if(GK.GM){
                    const GN=GK.GM
                    GL.GO= GN.GP??[1,1,1,1]
                    GL.B=GN.GQ?gltf.GI[GN.GQ.GH]:null//createTexture(Bx,[128,128,128,255])
                }
                GL.Y=GK.Y?(Fg.GI[GK.Y.GH]):null//createTexture(Bx,[0,0,255,255])
                GL.Z=GK.Z?(Fg.GI[GK.Z.GH]):null//createTexture(Bx,[128,128,128,255])
                return GL
            })
        
            Fg.GR=Fg.GR.map(Ey=>{
                let GS={geometry:{}}
                for(const DW of Object.keys(Ey.GT[0].BN)){
                    GS.DS[(DW.replace('GU','').GV()+'s').replace('GW','s')]=Fg.Fx[Ey.GT[0].BN[DW]]
                }
          
                GS.DS.DV=Fg.Fx[Ey.GT[0].DV]
                GS.GK=Fg.GJ ? Fg.GJ[Ey.GT[0].GK]:{}
          
                return GS
            })
        
            const GX = [];
            const GY = Fg.GZ;
            Fg.GZ = Fg.GZ.map((n) => {
              const {name, GE, Ey, CM, CO, CP} = n;
        
              const Ga = node(14)(CM, CO, CP);
              const Gb = node(16)(Ga, CZ);
              const Gc = Fg.GR[Ey];
              if (GE !== undefined) {
                GX.push({node: Gb, Ey: Gc, Gd: GE});
              } else if (Gc) {
                const Ey=node(30)(Cj,Gc.DS,Cn,node)
                Ey.DE=Gc.GK
                //node.add(Ey)
                //node.Ge.push(Ey);
                //engine.GR.push(Ey)
              }
              return Gb;
            });
        
            Fg.DO = (Fg.DO??[]).map((GE) => {
              const Es = GE.Es.map(Gf => Fg.GZ[Gf]);
              const Bw = Fg.Fx[GE.Gg]
              return node(37)(Bx,Es, Bw);
            });
        
            for (const {node:Gb, Ey, Gd} of GX) {
              //console.log('Bs K Ey: ',Ey)
              const Gh=node(30)(Cj,Ey.DS,Cn,Gb)
              Gh.DE=Ey.GK
              const GE=Fg.DO[Gd]
              Gh.GE=GE
              //node.add(Gh)
              //node.Ge.push(Gh);
              //engine.GR.push(Gh)
            }
        
            Fg.GZ.forEach((Gb, Gf) => {
              const CQ = GY[Gf].CQ;
              if (CQ) {
                Gi(Fg.GZ, Gb, CQ);
              }
            });
        
            for (const Ca of Fg.Gj) {
              Ca.Gk = node(16)(node(14)(), Ca.CZ);
              Gi(Fg.GZ, Ca.Gk, Ca.GZ);
            }
        
            Cj.add(Fg.Gj[0].Gk)
        
            console.log(Fg)

            //for(const Ey of Fg.GR){
            //    Cj.add(Ey)
            //}
        
            //node(3)(this,Fg)
        
            //gltf.Gj[0].Gk.CV()

            const K=node(16)()
            node(3)(K,Fg)


            return K

            
        })


        
        
        function Gi(GZ, Gb, Gl) {
            Gl.forEach((Gm) => {
                const CT = GZ[Gm];
                //child.Gn(node);
                Gb.add(CT)
            });
        }
        
        
        
        
    
    }
    
    

    {
    
        function Go(Gp, Bq, Gq) {
            Gp += (Bq - Gp)*Gq;
            return Gp
        }
        function Gr(Gp, Bq, Gq) {
            return Gp.map((p,i)=>lerp(Gp[i], Bq[i], Gq))
        }
        
       
        
        
        node(38,function(X){

            return
        
        
                if(!this.Gs){
                    this.Gs = {}
                }
        
        
                if(!this['Gt']||!this.Gt.length){
                    return
                }
        
                const GE=this['DO'][0]
        
                    const Gu=this.Gt[0]
        
        
        
                    this.Gs.DL = this.Gs.DL??0
                    this.Gs.Gq=this.Gs.Gq??0.0;
                    this.Gs.Gv=this.Gs.Gv??0
                    this.Gs.DM=this.Gs.DM??0
        
                
                    const Gw=0.035
        
                    this.Gs.Gq=this.Gs.DM/frametime
                    this.Gs.DM+=X
        
                    const Gx=()=>{
                    while(this.Gs.Gq>frametime){
                        this.Gs.DL++
                        this.Gs.DM=0
                        this.Gs.Gq=0
                    }
                    }
                    if(this.Gs.DL>this.Gs.Gv){
                    this.Gs.DL=0
                    Gx()
                    }
                    if(this.Gs.DM>frametime){
                    Gx()
                    }
                    
        
            for(const Gy of Gu['Gz']){
                    const Bq=Gy['Bq']
                    const HB=this.GZ[Bq['node']]
                    const FY=Gu['HC'][Gy['FY']]
                    
                    const HD={'CM':'HE','CO':'CO','CP':'CP',}[Gy.Bq['FC']]
                    const Dp=(HD==='CO')?4:3
        
        
                    const Fw=this.Fx[FY['HF']].Bw
                    
                    if(!this.Gs.Gv){
                        this.Gs.Gv=Fw.length/len
                    }
                
                    if(HD==='CO'){
                        var value=[Fw[(this.Gs.DL*Dp)+0],Fw[(this.Gs.DL*Dp)+1],Fw[(this.Gs.DL*Dp)+2],Fw[(this.Gs.DL*Dp)+3]]
                    }else{
                        var value=[Fw[(this.Gs.DL*Dp)+0],Fw[(this.Gs.DL*Dp)+1],Fw[(this.Gs.DL*Dp)+2]]
                    }
        
                    let HG=[value[0],value[1],value[2],value[3],]
                
                    const BH=Gr(HG, value, this.Gs.Gq)
        
                    HB.y[HD]=BH
                    }
        
        
        })
    
    }
    
    

    {
    
      
        
        node(37,function(Bx, Es, HH){
              this.Es = Es;
              this.Gg = [];
              this.HI = [];
            
              this.HJ = new Float32Array(Es.length * 16);
        
              for (let i = 0; i < Es.length; ++i) {
                this.Gg.push(new Float32Array(
                    HH.CG,
                    HH.GD + Float32Array.HK * 16 * i,
                    16));
                this.HI.push(new Float32Array(
                    this.HJ.CG,
                    Float32Array.HK * 16 * i,
                    16));
              }
        
              this.HL = Bx.createTexture();
              Bx.bindTexture(Bx.TEXTURE_2D, this.HL);
              Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MIN_FILTER, Bx.NEAREST);
              Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_MAG_FILTER, Bx.NEAREST);
              Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_S, Bx.CLAMP_TO_EDGE);
              Bx.texParameteri(Bx.TEXTURE_2D, Bx.TEXTURE_WRAP_T, Bx.CLAMP_TO_EDGE);
            
            
            return {
                HM(node) {
                const HN = By.CK()
                By.Ea(HN,node.CX);
            
                for (let j = 0; j < this.Es.length; ++j) {
                    const HB = this.Es[j];
                    const HO = this.HI[j];
                    By.CY(HO, HN, HB.CX);
                    By.CY(HO, HO, this.Gg[j]);
                }
                Bx.bindTexture(Bx.TEXTURE_2D, this.HL);
                Bx.texImage2D(Bx.TEXTURE_2D, 0, Bx.RGBA32F, 4, this.Es.length, 0,
                                Bx.RGBA, Bx.FLOAT, this.HJ);
                }
            }
        })


    
    }
    
    

{



    node(39,async function(Cj){



        //const Cj=await node(20)()
        const Bx=Cj.Bx



        const HP=5
        function HQ(){
            return (HP / 2)-Math.random()*HP
        }

        const HR=0.06812
        function CP(){
            return (HR / 3)+Math.random()*HR
        }

        const HS=0.072
        function HT(){
            return (HS / 10)+Math.random()*HS*0.13
        }




        const FO=await node(21)(Bx,"default")

        let DS=await node(4)("/models/box.json","json")
        DS=node(25)(DS)

        const B=node(23)(Bx,"/images/box.webp")

        const GR=[]

        const k=100.0;

        for(let x=0;x<count/3.5;x++){
            for(let y=0;y<count/28.0;y++){
                const Ey=node(31)(Cj, DS, FO)
                Ey.y.CM=[HQ(), HQ(), HQ()]
                const HR=CP()
                Ey.y.CP=[HR,HR,HR]
                Ey.y.HT=[HT(),HT(),HT()]

                Ey.DE={
                    B,
                }

                //mesh.Ez=Bx.LINE_STRIP;

                GR.push(Ey)
            }
        }



            for(const Ey of GR){

                Ey.DI=function(DH){

                    Ey.y.CO=Ey.y.CO.map((n,i)=>n+Ey.y.HT[i])

                }
            }
            //const CO=[DH*0.3, DH*0.12, DH*0.45]
            //this.y.CO=this.y.CO.map((n,i)=>n+CO[i])



        //engine.Ck.push(...GR)
















        //node(36)('./models/stickman/scene.Fg')





    })



}


{



    node(40,async function(Cj){



        //const Cj=await node(20)()
        const Bx=Cj.Bx



        

        const HU=[]
        for(let i=0;i<20;i++){
            HU.push({point:[Math.random(),Math.random(),0]})
        }


        //const HV=(HU.length/3)-2

        console.log('HU',HU)

        /*let Dp=1000000;
        let HW
        for(const HX of HU){
            const HY=Bz.Fa(HX.HX);
            HX.length=HY;
            if(HY<len){
                Dp=HY;
                HW=HX
            }
        }*/
        const HZ=[];

        function Ha(Hb){
            let Hc=[];

            for(const HX of HU){
                const Hd=Bz.Fb([],HX.HX,Hb.HX);
                HX.Dp=Bz.Fa(Hd);
            }
            let Dp=100000
            let He
            let Hf
            let Hg
            for(const HX of HU){
                if(HX!==Hb){
                    if(Dp>point.Dp){
                        Dp=HX.Dp;
                        Hg=Hf;
                        Hf=He;
                        He=HX;
                    }
                }
            }

            if(Hb&&point2&&point3){
                Hc.push([Hb,He,Hf])
            }
            if(He&&point4&&point3){
                Hc.push([He,Hg,Hf])
            }


            return Hc;
        }
        
        for(const HX of HU){
            const Hh=Ha(HX)
            if(Hh.length){
                HZ.push(...Hh);
            }
        }
        //var Hi = Hj.Hk(F);
        //var DT = Hj(Hi.Hl, Hi.Hm, Hi.Hn);
        const F=[]
        for(const Ho of HZ){
            F.push(...Ho)
        }
        //const DV = Hj(F,null,2);//earcut(F,[4]);
        //console.log('DV',DV)
        //const F=[]
        //for(const p of Hp){
        //    F.push(...HZ[p])
        //}
        //const DV=Hp

        const FO=await node(21)(Bx,"default")
    
        {

            //const F=[]
            //points.map(HQ=>positions.push(...HQ.HX))

            let DS={positions}
            
            DS=node(25)(DS)

            //const B=node(23)(Bx,"/wp-includes/images/box.webp")

            

            const Ey=node(31)(Cj, DS, FO)

            Ey.Ez=Bx.POINTS;

            //engine.Ck.push(Ey)
        }



        {
            const Hq=[]
            HZ.map(Hr=>triangle.map(HQ=>tpositions.push(...HQ.HX)))

            let Hs={positions:Hq}
            
            Hs=node(25)(Hs)

            //const B=node(23)(Bx,"/wp-includes/images/box.webp")

            

            const Ht=node(31)(Bx, Hs, FO)

            //tmesh.Ez=Bx.LINES;

            Cj.Ck.push(Ht)
        }
















        //node(36)('./models/stickman/scene.Fg')





    })



}


{



    node(41,async function(Cj){



        //const Cj=await node(20)()
        const Bx=Cj.Bx



        
        //engine.J.y.CM = Bz.CK()


        const FO=await node(21)(Bx,"render2d")

        let DS=await node(4)("/models/quad.json","json")
        
        DS=node(25)(DS)

        //const B=node(23)(Bx,"/wp-includes/images/box.webp")
        const B=node(23)(Bx,"/images/box.webp")
        

        const Ey=node(31)(Cj, DS, FO)

        Ey.y.CP=[0.8,0.8,0.8]

        Ey.DE.d=B


        //engine.Ck.push(Ey)
















        //node(36)('./models/stickman/scene.Fg')





    })



}


{



    node(42,async function(Cj){



        //const Cj=await node(20)()
        //const Bx=Cj.Bx





        

        await node(36)(Cj,'/models/stickman/scene.Fg')





    })



}


{

    node(43,async function(){


        const Cj=await node(20)()


        //node(41)()

        //node(40)()

        node(39)(Cj)


        //node(42)(Cj)









        node(44)()




    })

    /*window.addEventListener('Hu', () => {
        node(43)()
    })*/

    node(43)()









    node(44,function(){


        const w={}

        w["loadScene"]=function(){
            console.log('Ca Bs...')
        }

        node(2)(document.body, w)


    })




}

