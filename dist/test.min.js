function node(R,value){
    if(node[R]===undefined){
      node[R]=value
      return false
    }
    return node[R]
}

{

    
    /*S*/
    
    /*T*/
    
    node(0,async function U(V,W){
        const X=await fetch(V)
        const Y=await X[W??"text"]()
        return Y
    })
    
    node(1,function(Z){
      return new Float32Array(Z)
    })
    
    node(2,function(Z){
      return new Uint16Array(Z)
    })
    
    node(3,function(a,b){
      return Object.assign(a,b)
    })
    

}



{

    

    node(4,function(c){

      const d=node(5)
    const e=node(6)

    const f=c.canvas.width / c.canvas.height;

        const J={
            g: 5*9,
            f,
            h: 1/1000,
            i: 1000,

            I(){
              return d.j([], this.g, this.f, this.h, this.i)
            }
          }
        

        node(7)(J)

        return J


    })


}

{

    node(8,function(c){

        c.enable(c.DEPTH_TEST);
        c.depthFunc(c.LEQUAL);
        c.clearColor(0.0, 0.0, 0.0, 0.0);
        c.clearDepth(1.0);

    })

    node(9,function(c,k){

        const l=k ? k.m:null;

        //gl.bindFramebuffer(c.FRAMEBUFFER, l);

        if(k){
            c.viewport(0.0, 0.0, k.width, k.height);
        }else{
            c.viewport(0.0, 0.0, c.canvas.width, c.canvas.height);
        }
        c.clear(c.COLOR_BUFFER_BIT | c.DEPTH_BUFFER_BIT);


    })


    node(7,function(a){

        const d=node(5)
        const e=node(6)

        return Object.assign(a,{

            n:{
                o:e.p(),
                q:e.p(),
                r:e.p(1.0),
            },
            s(){
                const s=d.p()
                d.t(s, s, this.n.o);
                d.u(s, s, this.n.q[2], [0,0,1]);
                d.u(s, s, this.n.q[1], [0,1,0]);
                d.u(s, s, this.n.q[0], [1,0,0]);
                d.r(s, s, this.n.r);
                return s
            }

        })


    })


}

node(10,function(c,width,height){

    const k={
      width,
      height,
      m: c.createFramebuffer(),
      L: c.createTexture(),
      v: c.createTexture(),
    }

    // m
    c.bindFramebuffer(c.FRAMEBUFFER, k.m);
    k.m.width = width;
    k.m.height = height;

    // w
    c.bindTexture(c.TEXTURE_2D, k.L);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
    c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, k.m.width, k.m.height, 0, c.RGBA, c.UNSIGNED_BYTE, null);

    // x
    c.bindTexture(c.TEXTURE_2D, k.v);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
    c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
    c.texImage2D(c.TEXTURE_2D, 0, c.DEPTH_COMPONENT24, k.m.width, k.m.height, 0, c.DEPTH_COMPONENT, c.UNSIGNED_INT, null);

    // y z
    c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, k.L, 0);
    c.framebufferTexture2D(c.FRAMEBUFFER, c.DEPTH_ATTACHMENT, c.TEXTURE_2D, k.v, 0);

    //this.BB();

    //gl.bindTexture(c.TEXTURE_2D, null);
    //gl.bindRenderbuffer(c.RENDERBUFFER, null);
    c.bindFramebuffer(c.FRAMEBUFFER, null);

    return k

})

node(11,async function(BC,BD,BE,BF,BG){
        
        const c=BC.c

        let BH={
            "positions":[
                BF,BD,0.0,
                BF,BE,0.0,
                BG,BE,0.0,
                BG,BD,0.0 
         ],
         "indices": [3,2,1,3,1,0],
         "texcoords":[
             0,1,
             0,0,
             1,0,
             1,1
         ]
        }

        BH=node(12)(BH)

        const BI=await node(13)(c,'BJ')

        const BK=node(14)(c, BH, BI)

        //mesh.n.r=[0.8,0.8,0.8]

        //engine.BL.push(BK)


        //const BM={}

        return {
           // BM,
            BN(c,BM={}){
                //Object.assign(BM,this.BM)
                BK.BN(c,BM)
            }
        }
})


/*BO*/

{

    node(15,async function(canvas){

      

      if(canvas===undefined){
        canvas=document.createElement('canvas')
        canvas.width=window.innerWidth
        canvas.height=window.innerHeight
        document.body.append(canvas)
      }
      const c = canvas.getContext("webgl2")

      const BC={
        c,
        BL:[],
      }
      




    const k=node(10)(c,512,512)



    const BP=node(11);

    var BD=0, width=25
    var x=-(((BD-100)/100)*2)-1, BR=(width/100)*2
    const BS = await BP(BC, 1,0.5, -x, -x+BR)

    /*var BD=25, width=25
    var x=-(((BD-100)/100)*2)-1, BR=(width/100)*2
    this.BT = new BU(this, 1,0.5, -x, -x+BR)

    var BD=50, width=25
    var x=-(((BD-100)/100)*2)-1, BR=(width/100)*2
    this.BV = new BU(this, 1,0.5, -x, -x+BR)



    var BD=50, width=50
    var x=-(((BD-100)/100)*2)-1, BR=(width/100)*2
    this.BW = new BU(this, 0.0,-1.0, -x, -x+BR)*/











      








    const J=node(4)(c)
    J.n.o[2] = -6

    BC.J=J



      function BN(c, BM, BX){

        for(const K of BC.BL){
  
          if(K.BY){
            K.BY(BX)
          }
  
          K.BN(c, BM)
  
       }
  
      }



    node(8)(c)

    var BZ = 0;

    var BY = function(Ba) {


       const BX = (Ba-BZ)*0.001;




       BZ = Ba;


        const BM={
            I: J.I(),
            J: J.s(),
        }


       node(9)(c,k)
       BN(c, BM, BX)

       node(9)(c)
       BN(c, BM, BX)
       

       BM.Q=k.L
       BS.BN(c,BM)


       requestAnimationFrame(BY);


    }
    BY(0);

    return BC

    })



}


{


        node(12,function(BH){
            

            const Bc={}

            const Bd=["positions", "normals", "texcoords", "indices"]


            if(BH[Bd[0]]){
                Bc.F=BH[Bd[0]]
            }
            if(BH[Bd[1]]){
                Bc.G=BH[Bd[1]]
            }
            if(BH[Bd[2]]){
                Bc.H=BH[Bd[2]]
            }
            if(BH[Bd[3]]){
                Bc.Be=BH[Bd[3]]
            }



            for(const Bf of Object.keys(BH)){
                if(! Bd.includes(Bf)){
                    Bc[Bf]=BH[Bf]
                }
            }

            return Bc


        })



}

{

  const Bg = 0.000001;
  const Bh =  1/ Bg;

    function d(){
      return d.p()
    }



    node(3)(d,{

      p() {
        return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1]
      },
      
      Bi(a) {
        let Bj = [];
        Bj[0] = a[0];
        Bj[1] = a[1];
        Bj[2] = a[2];
        Bj[3] = a[3];
        Bj[4] = a[4];
        Bj[5] = a[5];
        Bj[6] = a[6];
        Bj[7] = a[7];
        Bj[8] = a[8];
        Bj[9] = a[9];
        Bj[10] = a[10];
        Bj[11] = a[11];
        Bj[12] = a[12];
        Bj[13] = a[13];
        Bj[14] = a[14];
        Bj[15] = a[15];
        return Bj;
      },

      t(Bj, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
        let Bk, Bl, Bm, Bn;
        let Bo, Bp, Bq, Br;
        let Bs, Bt, Bu, Bv;
      
        if (a === Bj) {
          Bj[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          Bj[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          Bj[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          Bj[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          Bk = a[0];
          Bl = a[1];
          Bm = a[2];
          Bn = a[3];
          Bo = a[4];
          Bp = a[5];
          Bq = a[6];
          Br = a[7];
          Bs = a[8];
          Bt = a[9];
          Bu = a[10];
          Bv = a[11];
      
          Bj[0] = Bk;
          Bj[1] = Bl;
          Bj[2] = Bm;
          Bj[3] = Bn;
          Bj[4] = Bo;
          Bj[5] = Bp;
          Bj[6] = Bq;
          Bj[7] = Br;
          Bj[8] = Bs;
          Bj[9] = Bt;
          Bj[10] = Bu;
          Bj[11] = Bv;
      
          Bj[12] = Bk * x + Bo * y + Bs * z + a[12];
          Bj[13] = Bl * x + Bp * y + Bt * z + a[13];
          Bj[14] = Bm * x + Bq * y + Bu * z + a[14];
          Bj[15] = Bn * x + Br * y + Bv * z + a[15];
        }
      
        return Bj;
      },

      r(Bj, a, v) {
        let x = v[0],
          y = v[1],
          z = v[2];
      
        Bj[0] = a[0] * x;
        Bj[1] = a[1] * x;
        Bj[2] = a[2] * x;
        Bj[3] = a[3] * x;
        Bj[4] = a[4] * y;
        Bj[5] = a[5] * y;
        Bj[6] = a[6] * y;
        Bj[7] = a[7] * y;
        Bj[8] = a[8] * z;
        Bj[9] = a[9] * z;
        Bj[10] = a[10] * z;
        Bj[11] = a[11] * z;
        Bj[12] = a[12];
        Bj[13] = a[13];
        Bj[14] = a[14];
        Bj[15] = a[15];
        return Bj;
      },

      u(Bj, a, Bw, Bx) {
        let x = Bx[0],
          y = Bx[1],
          z = Bx[2];
        let By = Math.hypot(x, y, z);
        let s, c, t;
        let Bk, Bl, Bm, Bn;
        let Bo, Bp, Bq, Br;
        let Bs, Bt, Bu, Bv;
        let Bz, CB, CC;
        let CD, CE, CF;
        let CG, CH, CI;
      
        if (By < Bg) {
          return null;
        }
      
        By = 1 / By;
        x *= By;
        y *= By;
        z *= By;
      
        s = Math.sin(Bw);
        c = Math.cos(Bw);
        t = 1 - c;
      
        Bk = a[0];
        Bl = a[1];
        Bm = a[2];
        Bn = a[3];
        Bo = a[4];
        Bp = a[5];
        Bq = a[6];
        Br = a[7];
        Bs = a[8];
        Bt = a[9];
        Bu = a[10];
        Bv = a[11];
      
        // CJ CK CL of CK q s
        Bz = x * x * t + c;
        CB = y * x * t + z * s;
        CC = z * x * t - y * s;
        CD = x * y * t - z * s;
        CE = y * y * t + c;
        CF = z * y * t + x * s;
        CG = x * z * t + y * s;
        CH = y * z * t - x * s;
        CI = z * z * t + c;
      
        // CM q-specific s CO
        Bj[0] = Bk * Bz + Bo * CB + Bs * CC;
        Bj[1] = Bl * Bz + Bp * CB + Bt * CC;
        Bj[2] = Bm * Bz + Bq * CB + Bu * CC;
        Bj[3] = Bn * Bz + Br * CB + Bv * CC;
        Bj[4] = Bk * CD + Bo * CE + Bs * CF;
        Bj[5] = Bl * CD + Bp * CE + Bt * CF;
        Bj[6] = Bm * CD + Bq * CE + Bu * CF;
        Bj[7] = Bn * CD + Br * CE + Bv * CF;
        Bj[8] = Bk * CG + Bo * CH + Bs * CI;
        Bj[9] = Bl * CG + Bp * CH + Bt * CI;
        Bj[10] = Bm * CG + Bq * CH + Bu * CI;
        Bj[11] = Bn * CG + Br * CH + Bv * CI;
      
        if (a !== Bj) {
          // CP CK n CQ CR CS, CT CK CU CV CW
          Bj[12] = a[12];
          Bj[13] = a[13];
          Bj[14] = a[14];
          Bj[15] = a[15];
        }
        return Bj;
      },

      CX(Bj, a, b) {
        let Bk = a[0],
          Bl = a[1],
          Bm = a[2],
          Bn = a[3];
        let Bo = a[4],
          Bp = a[5],
          Bq = a[6],
          Br = a[7];
        let Bs = a[8],
          Bt = a[9],
          Bu = a[10],
          Bv = a[11];
        let CY = a[12],
          CZ = a[13],
          Ca = a[14],
          Cb = a[15];
      
        // Cc Cd CK Ce Cf of CK Cg s
        let Ch = b[0],
          Ci = b[1],
          Cj = b[2],
          Ck = b[3];
        Bj[0] = Ch * Bk + Ci * Bo + Cj * Bs + Ck * CY;
        Bj[1] = Ch * Bl + Ci * Bp + Cj * Bt + Ck * CZ;
        Bj[2] = Ch * Bm + Ci * Bq + Cj * Bu + Ck * Ca;
        Bj[3] = Ch * Bn + Ci * Br + Cj * Bv + Ck * Cb;
      
        Ch = b[4];
        Ci = b[5];
        Cj = b[6];
        Ck = b[7];
        Bj[4] = Ch * Bk + Ci * Bo + Cj * Bs + Ck * CY;
        Bj[5] = Ch * Bl + Ci * Bp + Cj * Bt + Ck * CZ;
        Bj[6] = Ch * Bm + Ci * Bq + Cj * Bu + Ck * Ca;
        Bj[7] = Ch * Bn + Ci * Br + Cj * Bv + Ck * Cb;
      
        Ch = b[8];
        Ci = b[9];
        Cj = b[10];
        Ck = b[11];
        Bj[8] = Ch * Bk + Ci * Bo + Cj * Bs + Ck * CY;
        Bj[9] = Ch * Bl + Ci * Bp + Cj * Bt + Ck * CZ;
        Bj[10] = Ch * Bm + Ci * Bq + Cj * Bu + Ck * Ca;
        Bj[11] = Ch * Bn + Ci * Br + Cj * Bv + Ck * Cb;
      
        Ch = b[12];
        Ci = b[13];
        Cj = b[14];
        Ck = b[15];
        Bj[12] = Ch * Bk + Ci * Bo + Cj * Bs + Ck * CY;
        Bj[13] = Ch * Bl + Ci * Bp + Cj * Bt + Ck * CZ;
        Bj[14] = Ch * Bm + Ci * Bq + Cj * Bu + Ck * Ca;
        Bj[15] = Ch * Bn + Ci * Br + Cj * Bv + Ck * Cb;
        return Bj;
      },


      Cl(Bj, a) {
        let Bk = a[0],
          Bl = a[1],
          Bm = a[2],
          Bn = a[3];
        let Bo = a[4],
          Bp = a[5],
          Bq = a[6],
          Br = a[7];
        let Bs = a[8],
          Bt = a[9],
          Bu = a[10],
          Bv = a[11];
        let CY = a[12],
          CZ = a[13],
          Ca = a[14],
          Cb = a[15];
      
        let Bz = Bk * Bp - Bl * Bo;
        let CB = Bk * Bq - Bm * Bo;
        let CC = Bk * Br - Bn * Bo;
        let Cm = Bl * Bq - Bm * Bp;
        let Cn = Bl * Br - Bn * Bp;
        let Co = Bm * Br - Bn * Bq;
        let Cp = Bs * CZ - Bt * CY;
        let Cq = Bs * Ca - Bu * CY;
        let Cr = Bs * Cb - Bv * CY;
        let Cs = Bt * Ca - Bu * CZ;
        let CD = Bt * Cb - Bv * CZ;
        let CE = Bu * Cb - Bv * Ca;
      
        // Ct CK Cu
        let Cv =
          Bz * CE - CB * CD + CC * Cs + Cm * Cr - Cn * Cq + Co * Cp;
      
        if (!Cv) {
          return null;
        }
        Cv = 1.0 / Cv;
      
        Bj[0] = (Bp * CE - Bq * CD + Br * Cs) * Cv;
        Bj[1] = (Bm * CD - Bl * CE - Bn * Cs) * Cv;
        Bj[2] = (CZ * Co - Ca * Cn + Cb * Cm) * Cv;
        Bj[3] = (Bu * Cn - Bt * Co - Bv * Cm) * Cv;
        Bj[4] = (Bq * Cr - Bo * CE - Br * Cq) * Cv;
        Bj[5] = (Bk * CE - Bm * Cr + Bn * Cq) * Cv;
        Bj[6] = (Ca * CC - CY * Co - Cb * CB) * Cv;
        Bj[7] = (Bs * Co - Bu * CC + Bv * CB) * Cv;
        Bj[8] = (Bo * CD - Bp * Cr + Br * Cp) * Cv;
        Bj[9] = (Bl * Cr - Bk * CD - Bn * Cp) * Cv;
        Bj[10] = (CY * Cn - CZ * CC + Cb * Bz) * Cv;
        Bj[11] = (Bt * CC - Bs * Cn - Bv * Bz) * Cv;
        Bj[12] = (Bp * Cq - Bo * Cs - Bq * Cp) * Cv;
        Bj[13] = (Bk * Cs - Bl * Cq + Bm * Cp) * Cv;
        Bj[14] = (CZ * CB - CY * Cm - Ca * Bz) * Cv;
        Bj[15] = (Bs * Cm - Bt * CB + Bu * Bz) * Cv;
      
        return Bj;
      },
      
      //perspectiveNO
      j(Bj, Cx, f, h, i) {
        const Cy = 1.0 / Math.tan(Cx / 2);
        Bj[0] = Cy / f;
        Bj[1] = 0;
        Bj[2] = 0;
        Bj[3] = 0;
        Bj[4] = 0;
        Bj[5] = Cy;
        Bj[6] = 0;
        Bj[7] = 0;
        Bj[8] = 0;
        Bj[9] = 0;
        Bj[11] = -1;
        Bj[12] = 0;
        Bj[13] = 0;
        Bj[15] = 0;
        if (i != null && i !== Bh) {
          const Cz = 1 / (h - i);
          Bj[10] = (i + h) * Cz;
          Bj[14] = 2 * i * h * Cz;
        } else {
          Bj[10] = -1;
          Bj[14] = -2 * h;
        }
        return Bj;
      }


    
    })
    
    node(5,d)
    

}



{

    node(16,function(c,Z,DB){

      if(DB===undefined){
        DB = c.ARRAY_BUFFER
      }
      const k = c.createBuffer();
      c.bindBuffer(DB, k);
      c.bufferData(DB, Z, c.STATIC_DRAW);
      return k;

    })
    


    node(17,function(c,BI,k,DC,DD,DB){
      
      if(DB===undefined){
        DB=c.ARRAY_BUFFER
      }

      c.bindBuffer(DB, k);

       const l = c.getAttribLocation(BI, DC);

       if(l>-1){
          c.vertexAttribPointer(l, DD, c.FLOAT, false,0,0) ;
          c.enableVertexAttribArray(l);
       }

    })

    node(18,function(c,BH){

      const DE=node(1)
      const DF=node(2)

      const z={}

      for(const Bf of Object.keys(BH)){

        if(Bf==='Be'){

          z[Bf] = node(16)(c, DF(BH[Bf]), c.ELEMENT_ARRAY_BUFFER)

        }else{
          z[Bf] = node(16)(c, DE(BH[Bf]))
        }

      }
      
      return z

    })


    node(19,function(c,BI,z){

      const DG = c.createVertexArray();
      c.bindVertexArray(DG);

      for(const Bf of Object.keys(z)){

        let DH= (Bf==='Be')?1:3
        if(Bf==='H'){
          DH=2
        }
        let DB= (Bf==='Be')? c.ELEMENT_ARRAY_BUFFER: c.ARRAY_BUFFER

          node(17)(c,BI, z[Bf], Bf,DH,DB)
            
      }

      c.bindVertexArray(null);

      return DG

    })



    node(14,function(c,BH,BI){


      let z
      const BK={
        BH,
        z: z=node(18)(c, BH),
        BI,
        DG: node(19)(c,BI,z),
        DI:c.TRIANGLES,

        BN(c,BM){

            c.useProgram(this.BI);


           
            c.bindVertexArray(this.DG);

            
            const DJ=node(20)(c,this.BI)

            DJ.set(BM)
            DJ.set(this.BM??{})
            DJ.set({
              K:this.s(),
            })
          
          if(this.BH.Be){
            c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this.z.Be);

            c.drawElements(this.DI, this.BH.Be.length, c.UNSIGNED_SHORT, 0);
          }else{
            let DK=this.BH.F.length/3
            //if(this.DI===c.POINTS){
            //  DK=this.BH.F.length/3
            //}
            c.drawArrays(this.DI, 0, DK);
          }
        }
      }

      node(7)(BK)

      return BK


    })


}



{

    node(13,async function(c,DC){

      const U=node(0)

      let DL="/wp-includes/shaders"
      if(DO){
        DL="/shaders"
      }

      const DP = await U(DL+"/"+DC+".vert")
      const DR = await U(DL+"/"+DC+".frag")

      return node(21)(c,DP,DR)

    })

    node(22,function(c,DT,DU){

      const DV=c.createShader(DU);
      c.shaderSource(DV, DT);
      c.compileShader(DV);

      if (! c.getShaderParameter(DV, c.COMPILE_STATUS)) {
        console.log('DT',DT)
        console.log(c.getShaderInfoLog(DV));
      }

      return DV

    })


    node(21,async function(c,DP,DR){

      const DW = await node(22)(c,DP,c.VERTEX_SHADER)
      const DX = await node(22)(c,DR,c.FRAGMENT_SHADER)

      const BI = c.createProgram();
      c.attachShader(BI, DW);
      c.attachShader(BI, DX);
      c.linkProgram(BI);

      if (! c.getProgramParameter(BI, c.LINK_STATUS)) {
        console.log(c.getProgramInfoLog(BI));
      }

      return BI

    })

}


{





    node(23,function DY(c, DZ) {
        const Da = c.createTexture();
        c.bindTexture(c.TEXTURE_2D, Da);
     
        // Db Dc Dd De Df Dg Dh CK Di
        // Dj Dk Dl a Dm Dn Dj Do Dp.
        // Dq then Dr a Ds Dt Du CK Da Dv Dw Dx
        // Dy Dz EB. EC CK ED EE EF EG
        // Dw'EH EI CK Da EJ CK EK of CK ED.
        const EL = 0;
        const EM = c.RGBA;
        const width = 1;
        const height = 1;
        const EN = 0;
        const EO = c.RGBA;
        const EP = c.UNSIGNED_BYTE;
        const Dt = new Uint8Array([0, 0, 255, 255]);  // EQ ER
        c.texImage2D(c.TEXTURE_2D, EL, EM,
                    width, height, EN, EO, EP,
                    Dt);
     
        const ED = new Image();
        ED.onload = function() {
        c.bindTexture(c.TEXTURE_2D, Da);
        c.texImage2D(c.TEXTURE_2D, EL, EM,
                       EO, EP, ED);
     
        // ES EE ET EU for EV of 2 Dc
        // EW EX EV of 2 Dc Dv EY if CK ED EZ a
        // EV of 2 Du Ea Eb.
        if (Ec(ED.width) && Ec(ED.height)) {
           // Ed, Dz's a EV of 2. Ee Ef.
           c.generateMipmap(c.TEXTURE_2D);
        } else {
           // Eg, Dz's Eh a EV of 2. Ei of Ef CQ set
           // Ej De Ek De El
           c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
           c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
           c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR);
        }
        };
        ED.src = DZ;
     
        return Da;
     })
     
     function Ec(value) {
        return (value & (value - 1)) == 0;
     }




}

{


    node(20,function Em(c, En){
       
        let Eo=0
        c.activeTexture(c.TEXTURE0)
        c.bindTexture(c.TEXTURE_2D,null)
      
        return {
            set(BM){
                
                for(const Bf of Object.keys(BM)){

                    const l = c.getUniformLocation(En,Bf)
                    const Ep=BM[Bf]
                
                    if((! l)||(Ep===undefined)){
                        return
                    }
                    
                    
                    
                    if((Ep!==undefined)&&(Ep["constructor"]["name"]==="WebGLTexture")){
                        c.uniform1i(l,Eo)
                        c.activeTexture(c.TEXTURE0+Eo)
                        c.bindTexture(c.TEXTURE_2D,Ep)
                        Eo++
                    }else{
                        
                        switch(Ep.length) {
                            case 16:
                                c.uniformMatrix4fv(l,null,Ep)
                                break;
                            case 4:
                                c.uniform4fv(l,Ep)
                                break;
                            case 3:
                                c.uniform3fv(l,Ep)
                                break;
                            case 2:
                                c.uniform2fv(l,Ep)
                                break;
                            Eq:
                                c.uniform1f(l,Ep)
                          }
                        

                    }
            
                }
                
            }
        }
    })


}

{


    function e(){
        return e.p()
      }

    node(3)(e,{

        p(x,y,z) {
          if(x===undefined){
            x=0.0
          }
          if(y===undefined){
            y=x
          }
          if(z===undefined){
            z=y
          }
          return [x,y,z]
        },

        Er(a){
          let x = a[0];
          let y = a[1];
          let z = a[2];
          return Math.hypot(x, y, z);
        },

        add(Bj, a, b) {
          Bj[0] = a[0] + b[0];
          Bj[1] = a[1] + b[1];
          Bj[2] = a[2] + b[2];
          return Bj;
        },
        
        Es(Bj, a, b) {
          Bj[0] = a[0] - b[0];
          Bj[1] = a[1] - b[1];
          Bj[2] = a[2] - b[2];
          return Bj;
        }

    })


    node(6,e)


}

{



    node(24,async function(){



        const BC=await node(15)()
        const c=BC.c



        const Et=5
        function Eu(){
            return (Et / 2)-Math.random()*Et
        }

        const Ev=0.2
        function r(){
            return (Ev / 3)+Math.random()*Ev
        }

        const Ew=0.072
        function Ex(){
            return (Ew / 10)+Math.random()*Ew*0.13
        }




        const BI=await node(13)(c,"default")

        let BH=await node(0)("/wp-includes/models/box.json","json")
        BH=node(12)(BH)

        const B=node(23)(c,"/wp-includes/images/box.webp")

        const FC=[]

        for(let i=0;i<20;i++){
            const BK=node(14)(c, BH, BI)
            BK.n.o=[Eu(), Eu(), Eu()]
            const Ev=r()
            BK.n.r=[Ev,Ev,Ev]
            BK.n.Ex=[Ex(),Ex(),Ex()]

            BK.BM={
                B,
            }

            //mesh.DI=c.LINE_STRIP;

            FC.push(BK)
        }



            for(const BK of FC){

                BK.BY=function(BX){

                    BK.n.q=BK.n.q.map((n,i)=>n+BK.n.Ex[i])

                }
            }
            //const q=[BX*0.3, BX*0.12, BX*0.45]
            //this.n.q=this.n.q.map((n,i)=>n+q[i])



        BC.BL.push(...FC)
















        //node(25)('./models/stickman/scene.FF')





    })



}


{



    node(26,async function(){



        const BC=await node(15)()
        const c=BC.c



        

        const FG=[]
        for(let i=0;i<20;i++){
            FG.push({point:[Math.random(),Math.random(),0]})
        }


        //const FH=(FG.length/3)-2

        console.log('FG',FG)

        /*let By=1000000;
        let FI
        for(const FJ of FG){
            const FK=e.Er(FJ.FJ);
            FJ.length=FK;
            if(FK<len){
                By=FK;
                FI=FJ
            }
        }*/
        const FL=[];

        function FM(FN){
            let FO=[];

            for(const FJ of FG){
                const FP=e.Es([],FJ.FJ,FN.FJ);
                FJ.By=e.Er(FP);
            }
            let By=100000
            let FQ
            let FR
            let FS
            for(const FJ of FG){
                if(FJ!==FN){
                    if(By>point.By){
                        By=FJ.By;
                        FS=FR;
                        FR=FQ;
                        FQ=FJ;
                    }
                }
            }

            if(FN&&point2&&point3){
                FO.push([FN,FQ,FR])
            }
            if(FQ&&point4&&point3){
                FO.push([FQ,FS,FR])
            }


            return FO;
        }
        
        for(const FJ of FG){
            const FT=FM(FJ)
            if(FT.length){
                FL.push(...FT);
            }
        }
        //var FU = FV.FW(F);
        //var Bc = FV(FU.FX, FU.FY, FU.Eb);
        const F=[]
        for(const FZ of FL){
            F.push(...FZ)
        }
        //const Be = FV(F,null,2);//earcut(F,[4]);
        //console.log('Be',Be)
        //const F=[]
        //for(const p of Fa){
        //    F.push(...FL[p])
        //}
        //const Be=Fa

        const BI=await node(13)(c,"default")
    
        {

            //const F=[]
            //points.map(Eu=>positions.push(...Eu.FJ))

            let BH={positions}
            
            BH=node(12)(BH)

            //const B=node(23)(c,"/wp-includes/images/box.webp")

            

            const BK=node(14)(c, BH, BI)

            BK.DI=c.POINTS;

            BC.BL.push(BK)
        }



        {
            const Fb=[]
            FL.map(Fc=>triangle.map(Eu=>tpositions.push(...Eu.FJ)))

            let Fd={positions:Fb}
            
            Fd=node(12)(Fd)

            //const B=node(23)(c,"/wp-includes/images/box.webp")

            

            const Fe=node(14)(c, Fd, BI)

            //tmesh.DI=c.LINES;

            BC.BL.push(Fe)
        }
















        //node(25)('./models/stickman/scene.FF')





    })



}


{



    node(27,async function(){



        const BC=await node(15)()
        const c=BC.c



        
        //engine.J.n.o = e.p()


        const BI=await node(13)(c,"render2d")

        let BH=await node(0)("/wp-includes/models/quad.json","json")
        
        BH=node(12)(BH)

        //const B=node(23)(c,"/wp-includes/images/box.webp")

        

        const BK=node(14)(c, BH, BI)

        BK.n.r=[0.8,0.8,0.8]


        BC.BL.push(BK)
















        //node(25)('./models/stickman/scene.FF')





    })



}


{

    node(28,function(){


        //node(27)()

        //node(26)()

        node(24)()


    })

    /*window.addEventListener('Fg', () => {
        node(28)()
    })*/

    node(28)()

}



